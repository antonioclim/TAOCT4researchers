<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Traversal Animation — BFS vs DFS</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent-blue: #3b82f6;
            --accent-green: #22c55e;
            --accent-orange: #f97316;
            --accent-purple: #a855f7;
            --accent-red: #ef4444;
            --accent-cyan: #06b6d4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
        }

        .visualisation-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid var(--bg-tertiary);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16/10;
            background: var(--bg-primary);
            border-radius: 12px;
            overflow: hidden;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
        }

        .control-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .panel-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .panel-title {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }

        .algorithm-selector {
            display: flex;
            gap: 0.5rem;
        }

        .algo-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 2px solid var(--bg-tertiary);
            background: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .algo-btn:hover {
            border-color: var(--accent-blue);
        }

        .algo-btn.active {
            border-color: var(--accent-blue);
            background: var(--accent-blue);
        }

        .algo-btn.bfs.active {
            border-color: var(--accent-green);
            background: var(--accent-green);
        }

        .algo-btn.dfs.active {
            border-color: var(--accent-orange);
            background: var(--accent-orange);
        }

        .graph-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .graph-btn {
            padding: 0.5rem;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-primary);
            color: var(--text-secondary);
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .graph-btn:hover {
            border-color: var(--accent-purple);
            color: var(--text-primary);
        }

        .graph-btn.active {
            border-color: var(--accent-purple);
            background: var(--accent-purple);
            color: var(--text-primary);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .speed-control input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
        }

        .speed-label {
            min-width: 60px;
            text-align: right;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .action-btn {
            flex: 1;
            padding: 0.875rem 1rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-start {
            background: var(--accent-green);
            color: white;
        }

        .btn-start:hover {
            background: #16a34a;
        }

        .btn-step {
            background: var(--accent-blue);
            color: white;
        }

        .btn-step:hover {
            background: #2563eb;
        }

        .btn-reset {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-reset:hover {
            background: #475569;
        }

        .btn-pause {
            background: var(--accent-orange);
            color: white;
        }

        .state-display {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .state-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--bg-tertiary);
        }

        .state-row:last-child {
            border-bottom: none;
        }

        .state-label {
            color: var(--text-secondary);
        }

        .state-value {
            color: var(--accent-cyan);
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .legend-unvisited { background: var(--bg-tertiary); border: 2px solid #64748b; }
        .legend-frontier { background: var(--accent-blue); }
        .legend-current { background: var(--accent-orange); }
        .legend-visited { background: var(--accent-green); }

        .traversal-order {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1rem;
            min-height: 60px;
        }

        .traversal-order-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .order-nodes {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
        }

        .order-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            background: var(--accent-green);
            color: white;
            animation: nodeAppear 0.3s ease;
        }

        @keyframes nodeAppear {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .info-panel {
            margin-top: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid var(--bg-tertiary);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }

        .info-section h3 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-section h3.bfs-title { color: var(--accent-green); }
        .info-section h3.dfs-title { color: var(--accent-orange); }

        .info-section p {
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 0.9rem;
        }

        .complexity-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            font-size: 0.8rem;
            color: var(--accent-cyan);
            margin-top: 0.5rem;
        }

        .data-structure-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--accent-purple);
            border-radius: 4px;
            font-size: 0.75rem;
            color: white;
            margin-left: 0.5rem;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Graph Traversal Visualisation</h1>
            <p class="subtitle">Interactive comparison of Breadth-First Search and Depth-First Search algorithms</p>
        </header>

        <div class="main-content">
            <div class="visualisation-panel">
                <div class="canvas-container">
                    <canvas id="graphCanvas"></canvas>
                </div>
            </div>

            <div class="control-panel">
                <div class="panel-section">
                    <span class="panel-title">Algorithm</span>
                    <div class="algorithm-selector">
                        <button class="algo-btn bfs active" data-algo="bfs">BFS</button>
                        <button class="algo-btn dfs" data-algo="dfs">DFS</button>
                    </div>
                </div>

                <div class="panel-section">
                    <span class="panel-title">Graph Type</span>
                    <div class="graph-selector">
                        <button class="graph-btn active" data-graph="tree">Binary Tree</button>
                        <button class="graph-btn" data-graph="grid">Grid Graph</button>
                        <button class="graph-btn" data-graph="random">Random Graph</button>
                        <button class="graph-btn" data-graph="cyclic">Cyclic Graph</button>
                    </div>
                </div>

                <div class="panel-section">
                    <span class="panel-title">Animation Speed</span>
                    <div class="speed-control">
                        <input type="range" id="speedSlider" min="100" max="2000" value="800">
                        <span class="speed-label" id="speedLabel">800ms</span>
                    </div>
                </div>

                <div class="panel-section">
                    <span class="panel-title">Controls</span>
                    <div class="action-buttons">
                        <button class="action-btn btn-start" id="startBtn">▶ Start</button>
                        <button class="action-btn btn-step" id="stepBtn">⏭ Step</button>
                        <button class="action-btn btn-reset" id="resetBtn">↺ Reset</button>
                    </div>
                </div>

                <div class="panel-section">
                    <span class="panel-title">Legend</span>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color legend-unvisited"></div>
                            <span>Unvisited</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color legend-frontier"></div>
                            <span>In Queue/Stack</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color legend-current"></div>
                            <span>Current Node</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color legend-visited"></div>
                            <span>Visited</span>
                        </div>
                    </div>
                </div>

                <div class="panel-section">
                    <span class="panel-title">Data Structure State</span>
                    <div class="state-display" id="stateDisplay">
                        <div class="state-row">
                            <span class="state-label">Structure:</span>
                            <span class="state-value" id="structureName">Queue (FIFO)</span>
                        </div>
                        <div class="state-row">
                            <span class="state-label">Contents:</span>
                            <span class="state-value" id="structureContents">[ ]</span>
                        </div>
                        <div class="state-row">
                            <span class="state-label">Current:</span>
                            <span class="state-value" id="currentNode">—</span>
                        </div>
                        <div class="state-row">
                            <span class="state-label">Step:</span>
                            <span class="state-value" id="stepCount">0</span>
                        </div>
                    </div>
                </div>

                <div class="panel-section">
                    <span class="panel-title">Traversal Order</span>
                    <div class="traversal-order">
                        <div class="order-nodes" id="orderNodes"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-grid">
                <div class="info-section">
                    <h3 class="bfs-title">
                        Breadth-First Search
                        <span class="data-structure-badge">Queue</span>
                    </h3>
                    <p>
                        BFS explores vertices level by level, visiting all neighbours of the current vertex
                        before moving to vertices at the next depth level. This guarantees finding the
                        shortest path in unweighted graphs. The algorithm uses a <strong>queue</strong>
                        (FIFO — First In, First Out) to track the frontier of exploration.
                    </p>
                    <span class="complexity-badge">Time: O(V + E) | Space: O(V)</span>
                </div>
                <div class="info-section">
                    <h3 class="dfs-title">
                        Depth-First Search
                        <span class="data-structure-badge">Stack</span>
                    </h3>
                    <p>
                        DFS explores as far as possible along each branch before backtracking. It dives
                        deep into the graph structure before exploring siblings. The algorithm uses a
                        <strong>stack</strong> (LIFO — Last In, First Out), which can be implemented
                        explicitly or via recursion's call stack.
                    </p>
                    <span class="complexity-badge">Time: O(V + E) | Space: O(V)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════
        // GRAPH TRAVERSAL VISUALISATION ENGINE
        // ═══════════════════════════════════════════════════════════════

        class GraphVisualisation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // State
                this.nodes = [];
                this.edges = [];
                this.adjacencyList = new Map();
                
                // Traversal state
                this.algorithm = 'bfs';
                this.frontier = [];
                this.visited = new Set();
                this.current = null;
                this.traversalOrder = [];
                this.stepCount = 0;
                
                // Animation
                this.isRunning = false;
                this.animationSpeed = 800;
                this.animationId = null;

                // Node states
                this.nodeStates = new Map();

                // Colours
                this.colours = {
                    unvisited: '#475569',
                    unvisitedBorder: '#64748b',
                    frontier: '#3b82f6',
                    current: '#f97316',
                    visited: '#22c55e',
                    edge: '#475569',
                    edgeHighlight: '#a855f7',
                    text: '#f8fafc',
                    background: '#0f172a'
                };

                this.initGraph('tree');
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.width = rect.width;
                this.height = rect.height;
                this.draw();
            }

            // ─────────────────────────────────────────────────────────────
            // Graph Generation
            // ─────────────────────────────────────────────────────────────

            initGraph(type) {
                this.reset();
                
                switch(type) {
                    case 'tree':
                        this.createBinaryTree();
                        break;
                    case 'grid':
                        this.createGridGraph();
                        break;
                    case 'random':
                        this.createRandomGraph();
                        break;
                    case 'cyclic':
                        this.createCyclicGraph();
                        break;
                }

                this.buildAdjacencyList();
                this.draw();
            }

            createBinaryTree() {
                // 15-node complete binary tree
                const levels = 4;
                const nodeRadius = 22;
                let id = 0;

                for (let level = 0; level < levels; level++) {
                    const nodesInLevel = Math.pow(2, level);
                    const levelY = 60 + level * 90;
                    const startX = this.width / 2 - (nodesInLevel - 1) * (this.width / Math.pow(2, level + 1)) / 2;

                    for (let i = 0; i < nodesInLevel; i++) {
                        const spacing = this.width / Math.pow(2, level + 1);
                        const x = this.width / 2 + (i - (nodesInLevel - 1) / 2) * spacing;
                        
                        this.nodes.push({
                            id: id,
                            x: x,
                            y: levelY,
                            radius: nodeRadius,
                            label: String.fromCharCode(65 + id) // A, B, C, ...
                        });

                        // Connect to parent
                        if (id > 0) {
                            const parentId = Math.floor((id - 1) / 2);
                            this.edges.push({ from: parentId, to: id });
                        }

                        id++;
                    }
                }
            }

            createGridGraph() {
                const rows = 4;
                const cols = 5;
                const nodeRadius = 20;
                const spacingX = (this.width - 100) / (cols - 1);
                const spacingY = (this.height - 100) / (rows - 1);
                let id = 0;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.nodes.push({
                            id: id,
                            x: 50 + c * spacingX,
                            y: 50 + r * spacingY,
                            radius: nodeRadius,
                            label: String.fromCharCode(65 + id)
                        });

                        // Connect to left neighbour
                        if (c > 0) {
                            this.edges.push({ from: id - 1, to: id });
                        }
                        // Connect to top neighbour
                        if (r > 0) {
                            this.edges.push({ from: id - cols, to: id });
                        }

                        id++;
                    }
                }
            }

            createRandomGraph() {
                const numNodes = 12;
                const nodeRadius = 22;
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const maxRadius = Math.min(this.width, this.height) / 2 - 60;

                // Place nodes in a somewhat circular pattern with randomisation
                for (let i = 0; i < numNodes; i++) {
                    const angle = (2 * Math.PI * i / numNodes) + (Math.random() - 0.5) * 0.5;
                    const radius = maxRadius * (0.5 + Math.random() * 0.5);
                    
                    this.nodes.push({
                        id: i,
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        radius: nodeRadius,
                        label: String.fromCharCode(65 + i)
                    });
                }

                // Create a connected graph with some extra edges
                // First, ensure connectivity with a spanning tree
                const connected = new Set([0]);
                const remaining = new Set([...Array(numNodes).keys()].slice(1));

                while (remaining.size > 0) {
                    const from = [...connected][Math.floor(Math.random() * connected.size)];
                    const to = [...remaining][Math.floor(Math.random() * remaining.size)];
                    this.edges.push({ from: Math.min(from, to), to: Math.max(from, to) });
                    connected.add(to);
                    remaining.delete(to);
                }

                // Add some extra random edges
                for (let i = 0; i < numNodes / 2; i++) {
                    const from = Math.floor(Math.random() * numNodes);
                    let to = Math.floor(Math.random() * numNodes);
                    while (to === from) to = Math.floor(Math.random() * numNodes);
                    
                    const edgeExists = this.edges.some(e => 
                        (e.from === Math.min(from, to) && e.to === Math.max(from, to))
                    );
                    
                    if (!edgeExists) {
                        this.edges.push({ from: Math.min(from, to), to: Math.max(from, to) });
                    }
                }
            }

            createCyclicGraph() {
                const numNodes = 8;
                const nodeRadius = 24;
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const radius = Math.min(this.width, this.height) / 2 - 80;

                // Create outer ring
                for (let i = 0; i < numNodes; i++) {
                    const angle = (2 * Math.PI * i / numNodes) - Math.PI / 2;
                    
                    this.nodes.push({
                        id: i,
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        radius: nodeRadius,
                        label: String.fromCharCode(65 + i)
                    });

                    // Connect to next node (ring)
                    this.edges.push({ from: i, to: (i + 1) % numNodes });
                }

                // Add cross-connections for interesting traversal patterns
                this.edges.push({ from: 0, to: 3 });
                this.edges.push({ from: 1, to: 5 });
                this.edges.push({ from: 2, to: 6 });
                this.edges.push({ from: 4, to: 7 });
            }

            buildAdjacencyList() {
                this.adjacencyList.clear();
                
                for (const node of this.nodes) {
                    this.adjacencyList.set(node.id, []);
                }

                for (const edge of this.edges) {
                    this.adjacencyList.get(edge.from).push(edge.to);
                    this.adjacencyList.get(edge.to).push(edge.from);
                }

                // Sort neighbours for consistent ordering
                for (const [id, neighbours] of this.adjacencyList) {
                    neighbours.sort((a, b) => a - b);
                }
            }

            // ─────────────────────────────────────────────────────────────
            // Traversal Algorithms
            // ─────────────────────────────────────────────────────────────

            setAlgorithm(algo) {
                this.algorithm = algo;
                this.reset();
                this.updateStateDisplay();
            }

            step() {
                if (this.frontier.length === 0 && this.visited.size === 0) {
                    // Initialise with first node
                    this.frontier.push(0);
                    this.nodeStates.set(0, 'frontier');
                    this.updateStateDisplay();
                    this.draw();
                    return true;
                }

                if (this.frontier.length === 0) {
                    return false; // Traversal complete
                }

                // Get next node based on algorithm
                let currentId;
                if (this.algorithm === 'bfs') {
                    currentId = this.frontier.shift(); // Queue: FIFO
                } else {
                    currentId = this.frontier.pop(); // Stack: LIFO
                }

                // Skip if already visited
                if (this.visited.has(currentId)) {
                    return this.step();
                }

                // Process current node
                this.current = currentId;
                this.visited.add(currentId);
                this.nodeStates.set(currentId, 'current');
                this.traversalOrder.push(currentId);
                this.stepCount++;

                // Add unvisited neighbours to frontier
                const neighbours = this.adjacencyList.get(currentId) || [];
                for (const neighbour of neighbours) {
                    if (!this.visited.has(neighbour) && !this.frontier.includes(neighbour)) {
                        this.frontier.push(neighbour);
                        if (this.nodeStates.get(neighbour) !== 'visited') {
                            this.nodeStates.set(neighbour, 'frontier');
                        }
                    }
                }

                // Update current node to visited after a brief moment
                setTimeout(() => {
                    if (this.nodeStates.get(currentId) === 'current') {
                        this.nodeStates.set(currentId, 'visited');
                        this.current = null;
                        this.draw();
                    }
                }, this.animationSpeed / 2);

                this.updateStateDisplay();
                this.updateTraversalOrderDisplay();
                this.draw();

                return true;
            }

            async run() {
                this.isRunning = true;
                document.getElementById('startBtn').innerHTML = '⏸ Pause';
                document.getElementById('startBtn').classList.add('btn-pause');
                document.getElementById('startBtn').classList.remove('btn-start');

                while (this.isRunning && this.step()) {
                    await new Promise(resolve => setTimeout(resolve, this.animationSpeed));
                }

                this.isRunning = false;
                document.getElementById('startBtn').innerHTML = '▶ Start';
                document.getElementById('startBtn').classList.remove('btn-pause');
                document.getElementById('startBtn').classList.add('btn-start');
            }

            pause() {
                this.isRunning = false;
                document.getElementById('startBtn').innerHTML = '▶ Start';
                document.getElementById('startBtn').classList.remove('btn-pause');
                document.getElementById('startBtn').classList.add('btn-start');
            }

            reset() {
                this.pause();
                this.frontier = [];
                this.visited = new Set();
                this.current = null;
                this.traversalOrder = [];
                this.stepCount = 0;
                this.nodeStates.clear();
                this.updateStateDisplay();
                this.updateTraversalOrderDisplay();
                this.draw();
            }

            // ─────────────────────────────────────────────────────────────
            // Rendering
            // ─────────────────────────────────────────────────────────────

            draw() {
                const ctx = this.ctx;
                
                // Clear canvas
                ctx.fillStyle = this.colours.background;
                ctx.fillRect(0, 0, this.width, this.height);

                // Draw edges
                for (const edge of this.edges) {
                    const fromNode = this.nodes[edge.from];
                    const toNode = this.nodes[edge.to];
                    
                    const isHighlighted = 
                        (this.visited.has(edge.from) && this.visited.has(edge.to)) ||
                        (this.current === edge.from || this.current === edge.to);

                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.strokeStyle = isHighlighted ? this.colours.edgeHighlight : this.colours.edge;
                    ctx.lineWidth = isHighlighted ? 3 : 2;
                    ctx.stroke();
                }

                // Draw nodes
                for (const node of this.nodes) {
                    const state = this.nodeStates.get(node.id) || 'unvisited';
                    
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    
                    // Fill based on state
                    switch (state) {
                        case 'frontier':
                            ctx.fillStyle = this.colours.frontier;
                            break;
                        case 'current':
                            ctx.fillStyle = this.colours.current;
                            break;
                        case 'visited':
                            ctx.fillStyle = this.colours.visited;
                            break;
                        default:
                            ctx.fillStyle = this.colours.unvisited;
                    }
                    ctx.fill();

                    // Border for unvisited nodes
                    if (state === 'unvisited') {
                        ctx.strokeStyle = this.colours.unvisitedBorder;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    // Draw label
                    ctx.fillStyle = this.colours.text;
                    ctx.font = 'bold 14px system-ui, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.label, node.x, node.y);
                }
            }

            // ─────────────────────────────────────────────────────────────
            // UI Updates
            // ─────────────────────────────────────────────────────────────

            updateStateDisplay() {
                const structureName = document.getElementById('structureName');
                const structureContents = document.getElementById('structureContents');
                const currentNode = document.getElementById('currentNode');
                const stepCount = document.getElementById('stepCount');

                structureName.textContent = this.algorithm === 'bfs' ? 'Queue (FIFO)' : 'Stack (LIFO)';
                
                const frontierLabels = this.frontier.map(id => this.nodes[id].label);
                structureContents.textContent = `[ ${frontierLabels.join(', ')} ]`;
                
                currentNode.textContent = this.current !== null ? this.nodes[this.current].label : '—';
                stepCount.textContent = this.stepCount.toString();
            }

            updateTraversalOrderDisplay() {
                const container = document.getElementById('orderNodes');
                container.innerHTML = '';
                
                for (const nodeId of this.traversalOrder) {
                    const div = document.createElement('div');
                    div.className = 'order-node';
                    div.textContent = this.nodes[nodeId].label;
                    container.appendChild(div);
                }
            }

            setSpeed(speed) {
                this.animationSpeed = speed;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // Initialisation and Event Handlers
        // ═══════════════════════════════════════════════════════════════

        document.addEventListener('DOMContentLoaded', () => {
            const viz = new GraphVisualisation('graphCanvas');

            // Algorithm selection
            document.querySelectorAll('.algo-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.algo-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    viz.setAlgorithm(btn.dataset.algo);
                });
            });

            // Graph selection
            document.querySelectorAll('.graph-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.graph-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    viz.initGraph(btn.dataset.graph);
                });
            });

            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            const speedLabel = document.getElementById('speedLabel');
            speedSlider.addEventListener('input', () => {
                const speed = parseInt(speedSlider.value);
                viz.setSpeed(speed);
                speedLabel.textContent = `${speed}ms`;
            });

            // Control buttons
            document.getElementById('startBtn').addEventListener('click', () => {
                if (viz.isRunning) {
                    viz.pause();
                } else {
                    viz.run();
                }
            });

            document.getElementById('stepBtn').addEventListener('click', () => {
                if (!viz.isRunning) {
                    viz.step();
                }
            });

            document.getElementById('resetBtn').addEventListener('click', () => {
                viz.reset();
            });
        });
    </script>
</body>
</html>
