<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 4: Structuri de Date Avansate | Computational Thinking</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/theme/night.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/monokai.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <style>
        :root { --r-heading-color: #58a6ff; }
        .reveal h1, .reveal h2 { text-transform: none; }
        .reveal .slides section { text-align: left; }
        
        .hook-box {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-left: 4px solid #e94560;
            padding: 20px 25px; margin: 20px 0;
            border-radius: 0 8px 8px 0; font-style: italic;
        }
        .hook-box .source { font-size: 0.7em; color: #888; margin-top: 10px; font-style: normal; }
        
        .definition-box {
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            border: 1px solid #58a6ff;
            padding: 20px; margin: 15px 0; border-radius: 8px;
        }
        .definition-box h4 { color: #58a6ff; margin: 0 0 10px 0; }
        
        .theorem-box {
            background: linear-gradient(135deg, #1a472a 0%, #16213e 100%);
            border: 1px solid #3fb950;
            padding: 20px; margin: 15px 0; border-radius: 8px;
        }
        .theorem-box h4 { color: #3fb950; margin: 0 0 10px 0; }
        
        .diagram-box {
            background: #0d1117; border: 1px solid #30363d;
            padding: 20px; border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.55em; line-height: 1.3;
        }
        
        .two-columns { display: flex; gap: 30px; }
        .two-columns > div { flex: 1; }
        
        .highlight-text { color: #ffa657; font-weight: bold; }
        .small-text { font-size: 0.75em; color: #8b949e; }
        
        table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.7em; }
        th, td { border: 1px solid #30363d; padding: 8px; text-align: left; }
        th { background: #161b22; color: #58a6ff; }
        
        .complexity-good { color: #3fb950; }
        .complexity-ok { color: #ffa657; }
        .complexity-bad { color: #f85149; }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            
            <!-- TITLE -->
            <section data-background-gradient="linear-gradient(135deg, #0d1117 0%, #161b22 100%)">
                <h1 style="font-size: 2em;">ğŸŒ³ SÄƒptÄƒmÃ¢na 4</h1>
                <h2 style="color: #58a6ff; font-size: 1.5em;">STRUCTURI DE DATE AVANSATE</h2>
                <p style="color: #8b949e; font-size: 0.9em;">
                    Hash Tables â€¢ Arbori â€¢ Grafuri â€¢ Bloom Filters
                </p>
                <hr style="border-color: #30363d; margin: 30px 0;">
                <p style="font-size: 0.7em; color: #8b949e;">
                    THE ART OF COMPUTATIONAL THINKING FOR RESEARCHERS<br>
                    Versiunea 2.1 â€” Editura X
                </p>
            </section>
            
            <!-- HOOK 1: Bitcoin -->
            <section>
                <h2>ğŸ”— Structuri care au schimbat lumea</h2>
                
                <div class="hook-box">
                    <p>
                        Ãn 2008, Satoshi Nakamoto a publicat whitepaper-ul Bitcoin. 
                        La bazÄƒ: un <strong>Merkle tree</strong> â€” o structurÄƒ de date inventatÄƒ 
                        Ã®n 1979 de Ralph Merkle.
                    </p>
                    <p>
                        FÄƒrÄƒ Merkle trees, blockchain-ul ar fi imposibil. Cu ele, 
                        poÈ›i verifica tranzacÈ›ii Ã®n O(log n) fÄƒrÄƒ a descÄƒrca Ã®ntregul lanÈ›.
                    </p>
                    <p class="source">
                        â€” La Ã®nceputul lui 2025, capitalizarea totalÄƒ a criptomonedelor 
                        depÄƒÈ™ea $2 trilioane â€” totul bazat pe structuri de date inventate 
                        cu decenii Ã®n urmÄƒ.
                    </p>
                </div>
            </section>
            
            <!-- AGENDA -->
            <section>
                <h2>ğŸ“‹ Agenda</h2>
                
                <table>
                    <tr><th>Timp</th><th>Modul</th><th>ConÈ›inut</th></tr>
                    <tr><td>0:00-0:50</td><td>Teorie</td><td>Hash tables, arbori echilibraÈ›i, grafuri</td></tr>
                    <tr><td>0:50-1:40</td><td>Python</td><td>collections internals, NetworkX</td></tr>
                    <tr><td>1:40-1:55</td><td colspan="2" style="text-align:center;">â˜• PauzÄƒ</td></tr>
                    <tr><td>1:55-2:45</td><td>C++</td><td>STL containers, custom allocators</td></tr>
                    <tr><td>2:45-3:30</td><td>JavaScript</td><td>D3.js graph visualization</td></tr>
                    <tr><td>3:30-4:00</td><td>Lab</td><td>BibliotecÄƒ de grafuri polyglot</td></tr>
                </table>
            </section>
            
            <!-- PART I: HASH TABLES -->
            <section>
                <section>
                    <h1>PARTEA I</h1>
                    <h2 style="color: #58a6ff;">Hash Tables</h2>
                    <p class="small-text">De ce O(1) nu e magie</p>
                </section>
                
                <!-- HASH FUNCTION -->
                <section>
                    <h2>FuncÈ›ia Hash: EsenÈ›a Structurii</h2>
                    
                    <div class="definition-box">
                        <h4>DefiniÈ›ie</h4>
                        <p>
                            O <strong>funcÈ›ie hash</strong> h: U â†’ {0, 1, ..., m-1} mapeazÄƒ 
                            un univers U de chei posibile la un set finit de m "bucket-uri".
                        </p>
                    </div>
                    
                    <div class="diagram-box">
<pre>
    Cheile din U           Hash function h           Tabelul (array)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  "Ana"  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   â”‚ 0: ("Ana", A) â”‚
    â”‚  "Bob"  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  h(k) = k mod m  â”€â”€â”€â–¶   â”‚ 1:            â”‚
    â”‚  "Eve"  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ 2: ("Eve", E) â”‚
    â”‚  "Dan"  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   â”‚ 3: ("Dan", D) â”‚
    â”‚  "Fay"  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ 4: ("Bob", B) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚    ("Fay", F) â”‚ â† COLIZIUNE!
                                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    COLIZIUNE: h("Bob") == h("Fay")
    
    Strategii de rezolvare:
    â”œâ”€â”€ Chaining: liste Ã®nlÄƒnÈ›uite Ã®n fiecare bucket
    â”œâ”€â”€ Open addressing: probing liniar/quadratic/double hashing
    â””â”€â”€ Robin Hood hashing: "furÄƒ de la bogaÈ›i"
</pre>
                    </div>
                </section>
                
                <!-- LOAD FACTOR -->
                <section>
                    <h2>Factorul de ÃncÄƒrcare</h2>
                    
                    <div class="definition-box">
                        <h4>Load Factor</h4>
                        <p>Î± = n/m unde n = numÄƒrul de elemente, m = numÄƒrul de bucket-uri</p>
                    </div>
                    
                    <table>
                        <tr>
                            <th>Î±</th>
                            <th>PerformanÈ›Äƒ CÄƒutare</th>
                            <th>Memorie</th>
                            <th>Recomandare</th>
                        </tr>
                        <tr>
                            <td>< 0.5</td>
                            <td class="complexity-good">ExcelentÄƒ</td>
                            <td class="complexity-bad">RisipÄƒ</td>
                            <td>OK pentru read-heavy</td>
                        </tr>
                        <tr>
                            <td>0.5-0.75</td>
                            <td class="complexity-good">Foarte bunÄƒ</td>
                            <td class="complexity-good">EficientÄƒ</td>
                            <td><strong>IDEAL</strong></td>
                        </tr>
                        <tr>
                            <td>0.75-0.9</td>
                            <td class="complexity-ok">BunÄƒ</td>
                            <td class="complexity-good">Foarte eficientÄƒ</td>
                            <td>OK pentru space-constrained</td>
                        </tr>
                        <tr>
                            <td>> 0.9</td>
                            <td class="complexity-bad">DegradatÄƒ</td>
                            <td class="complexity-good">MaximÄƒ</td>
                            <td>EvitaÈ›i!</td>
                        </tr>
                    </table>
                    
                    <p class="fragment small-text">
                        Python dict: resize la Î±=0.67. Java HashMap: resize la Î±=0.75.
                    </p>
                </section>
                
                <!-- HOOK 2: Google's Engineering -->
                <section>
                    <h2>Hash Tables Ã®n ProducÈ›ie</h2>
                    
                    <div class="hook-box">
                        <p>
                            Ãn 2017, Google a Ã®nlocuit <code>std::unordered_map</code> din Ã®ntreaga 
                            lor codebase cu o implementare custom numitÄƒ <strong>Swiss Table</strong> 
                            (absl::flat_hash_map).
                        </p>
                        <p>
                            Rezultat: ~1% reducere Ã®n utilizarea globalÄƒ de CPU a Google.
                            Pentru o companie de mÄƒrimea Google, asta Ã®nseamnÄƒ milioane de dolari 
                            economisiÈ›i anual.
                        </p>
                        <p class="source">
                            â€” CppCon 2017: "Designing a Fast, Efficient, Cache-friendly Hash Table"
                        </p>
                    </div>
                </section>
            </section>
            
            <!-- PART II: TREES -->
            <section>
                <section>
                    <h1>PARTEA II</h1>
                    <h2 style="color: #58a6ff;">Arbori EchilibraÈ›i</h2>
                    <p class="small-text">AVL, Red-Black, B-Trees</p>
                </section>
                
                <!-- BST PROBLEM -->
                <section>
                    <h2>Problema BST-urilor Simple</h2>
                    
                    <div class="two-columns">
                        <div>
                            <h4 style="color: #3fb950;">BST Echilibrat</h4>
                            <div class="diagram-box">
<pre>
        4
       / \
      2   6
     / \ / \
    1  3 5  7

    ÃnÄƒlÈ›ime: O(log n)
    CÄƒutare: O(log n)
</pre>
                            </div>
                        </div>
                        <div>
                            <h4 style="color: #f85149;">BST Degenerat</h4>
                            <div class="diagram-box">
<pre>
    1
     \
      2
       \
        3
         \
          4
           \
            5

    ÃnÄƒlÈ›ime: O(n)
    CÄƒutare: O(n) ğŸ˜±
</pre>
                            </div>
                        </div>
                    </div>
                    
                    <p class="fragment">
                        <strong>SoluÈ›ia:</strong> Arbori auto-echilibraÈ›i care menÈ›in 
                        h = O(log n) dupÄƒ orice operaÈ›ie.
                    </p>
                </section>
                
                <!-- AVL TREES -->
                <section>
                    <h2>AVL Trees (1962)</h2>
                    
                    <div class="definition-box">
                        <h4>Proprietatea AVL</h4>
                        <p>
                            Pentru orice nod, diferenÈ›a de Ã®nÄƒlÈ›ime Ã®ntre subarborele stÃ¢ng 
                            È™i cel drept (balance factor) este âˆˆ {-1, 0, 1}.
                        </p>
                    </div>
                    
                    <div class="diagram-box">
<pre>
    ROTAÈšIE SIMPLÄ‚ DREAPTA (dezechilibru LL):
    
    Ãnainte:            DupÄƒ:
        z                   y
       /                   / \
      y         â”€â”€â”€â–¶      x   z
     /
    x
    
    ROTAÈšIE DUBLÄ‚ STÃ‚NGA-DREAPTA (dezechilibru LR):
    
    Ãnainte:            Pas 1:              Pas 2:
        z                   z                   x
       /                   /                   / \
      y         â”€â”€â”€â–¶      x        â”€â”€â”€â–¶      y   z
       \                 /
        x               y
</pre>
                    </div>
                    
                    <p class="small-text fragment">
                        Complexitate: Insert/Delete/Search = O(log n) garantat.
                        Overhead: factor de echilibru per nod + rotaÈ›ii.
                    </p>
                </section>
                
                <!-- B-TREES -->
                <section>
                    <h2>B-Trees: Arbori pentru Disk</h2>
                    
                    <div class="hook-box" style="font-size: 0.9em;">
                        <p>
                            Fiecare query la baza de date foloseÈ™te B-Trees.
                            PostgreSQL, MySQL, SQLite â€” toate indexeazÄƒ cu B+ Trees.
                        </p>
                    </div>
                    
                    <div class="diagram-box">
<pre>
    B-Tree de ordin 3 (fiecare nod are 2-3 chei, 3-4 copii):
    
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   17 â”‚ 35   â”‚           â† RÄƒdÄƒcinÄƒ
                        â””â”€â”€â”¬â”€â”€â”´â”€â”€â”¬â”€â”€â”´â”€â”€â”˜
                           â”‚     â”‚     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                    â”‚                    â”‚
      â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
      â”‚  5 â”‚ 13   â”‚       â”‚ 22 â”‚ 28   â”‚       â”‚ 42 â”‚ 51   â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Avantaje pentru disk:
    â”œâ”€â”€ Noduri mari (100s de chei) = mai puÈ›ine I/O operations
    â”œâ”€â”€ ÃnÄƒlÈ›ime micÄƒ = ~3-4 nivele pentru miliarde de Ã®nregistrÄƒri
    â””â”€â”€ Acces secvenÈ›ial Ã®n frunze = range queries eficiente
</pre>
                    </div>
                </section>
            </section>
            
            <!-- PART III: GRAPHS -->
            <section>
                <section>
                    <h1>PARTEA III</h1>
                    <h2 style="color: #58a6ff;">Grafuri</h2>
                    <p class="small-text">Reprezentare, Traversare, Shortest Path</p>
                </section>
                
                <!-- GRAPH REPRESENTATIONS -->
                <section>
                    <h2>ReprezentÄƒri de Grafuri</h2>
                    
                    <div class="two-columns">
                        <div>
                            <h4>Matrice de AdiacenÈ›Äƒ</h4>
                            <div class="diagram-box" style="font-size: 0.55em;">
<pre>
Graf:                Matrice:
  0â”€â”€â”€1                0  1  2  3
  â”‚\ /â”‚              0 [0, 1, 1, 0]
  â”‚ X â”‚              1 [1, 0, 1, 1]
  â”‚/ \â”‚              2 [1, 1, 0, 1]
  2â”€â”€â”€3              3 [0, 1, 1, 0]

SpaÈ›iu: O(VÂ²)
Edge check: O(1)
All neighbors: O(V)

BUN pentru: grafuri dense
</pre>
                            </div>
                        </div>
                        <div>
                            <h4>Liste de AdiacenÈ›Äƒ</h4>
                            <div class="diagram-box" style="font-size: 0.55em;">
<pre>
Graf:                Liste:
  0â”€â”€â”€1              0: [1, 2]
  â”‚\ /â”‚              1: [0, 2, 3]
  â”‚ X â”‚              2: [0, 1, 3]
  â”‚/ \â”‚              3: [1, 2]
  2â”€â”€â”€3              

SpaÈ›iu: O(V + E)
Edge check: O(degree)
All neighbors: O(degree)

BUN pentru: grafuri sparse
</pre>
                            </div>
                        </div>
                    </div>
                    
                    <p class="fragment small-text">
                        <strong>Ãn practicÄƒ:</strong> Majoritatea grafurilor din lumea realÄƒ sunt sparse.
                        ReÈ›elele sociale: ~100-500 conexiuni per utilizator, nu milioane.
                    </p>
                </section>
                
                <!-- BFS vs DFS -->
                <section>
                    <h2>BFS vs DFS</h2>
                    
                    <div class="two-columns">
                        <div>
                            <h4>Breadth-First Search</h4>
                            <pre><code class="language-python" style="font-size: 0.65em;">
def bfs(graph, start):
    visited = {start}
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        yield node
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
                            </code></pre>
                            <p class="small-text">
                                âœ“ Shortest path (unweighted)<br>
                                âœ“ Level-order traversal<br>
                                Memorie: O(V)
                            </p>
                        </div>
                        <div>
                            <h4>Depth-First Search</h4>
                            <pre><code class="language-python" style="font-size: 0.65em;">
def dfs(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            yield node
            
            for neighbor in graph[node]:
                stack.append(neighbor)
                            </code></pre>
                            <p class="small-text">
                                âœ“ Topological sort<br>
                                âœ“ Cycle detection<br>
                                Memorie: O(h) recursiv
                            </p>
                        </div>
                    </div>
                </section>
                
                <!-- DIJKSTRA -->
                <section>
                    <h2>Dijkstra's Algorithm (1956)</h2>
                    
                    <div class="hook-box" style="font-size: 0.9em;">
                        <p>
                            Edsger Dijkstra a inventat algoritmul Ã®n 20 de minute, 
                            pe o terasÄƒ din Amsterdam, fÄƒrÄƒ hÃ¢rtie.
                        </p>
                        <p class="source">
                            â€” "One of the reasons that it is so nice was that I designed it without 
                            pencil and paper. I learned later that one of the advantages of designing 
                            without pencil and paper is that you are almost forced to avoid all 
                            avoidable complexities."
                        </p>
                    </div>
                    
                    <pre><code class="language-python" style="font-size: 0.7em;">
def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]  # (distance, node)
    
    while pq:
        d, u = heappop(pq)
        if d > dist[u]:
            continue  # Already found a better path
        
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heappush(pq, (dist[v], v))
    
    return dist
                    </code></pre>
                    
                    <p class="small-text">Complexitate: O((V + E) log V) cu binary heap</p>
                </section>
            </section>
            
            <!-- PART IV: PROBABILISTIC -->
            <section>
                <section>
                    <h1>PARTEA IV</h1>
                    <h2 style="color: #58a6ff;">Structuri Probabilistice</h2>
                    <p class="small-text">Bloom Filters, Count-Min Sketch</p>
                </section>
                
                <!-- BLOOM FILTERS -->
                <section>
                    <h2>Bloom Filter (1970)</h2>
                    
                    <div class="definition-box">
                        <h4>Ce este?</h4>
                        <p>
                            Un Bloom filter testeazÄƒ <em>membership</em> cu:
                            <ul>
                                <li><strong>No false negatives:</strong> DacÄƒ zice "nu e", sigur nu e</li>
                                <li><strong>Possible false positives:</strong> DacÄƒ zice "poate e", verificÄƒ!</li>
                            </ul>
                        </p>
                    </div>
                    
                    <div class="diagram-box">
<pre>
    Insert "cat":                      Check "dog":
    hâ‚("cat")=2, hâ‚‚("cat")=5          hâ‚("dog")=1, hâ‚‚("dog")=5
    
    [0, 0, 1, 0, 0, 1, 0, 0]          [0, 0, 1, 0, 0, 1, 0, 0]
           â†‘        â†‘                     â†‘           â†‘
           set     set                   0 â†’ NOT IN SET (certain!)
    
    Check "cat":
    hâ‚("cat")=2, hâ‚‚("cat")=5
    [0, 0, 1, 0, 0, 1, 0, 0]
           â†‘        â†‘
           1        1  â†’ MIGHT BE IN SET (verify!)
</pre>
                    </div>
                    
                    <p class="fragment small-text">
                        <strong>UtilizÄƒri:</strong> Cache lookup (Chrome), spam detection, 
                        database query optimization (Cassandra, PostgreSQL).
                    </p>
                </section>
                
                <!-- BLOOM MATH -->
                <section>
                    <h2>Matematica Bloom Filters</h2>
                    
                    <div class="theorem-box">
                        <h4>Probabilitatea de False Positive</h4>
                        <p>
                            Pentru n elemente, m biÈ›i, k funcÈ›ii hash:
                        </p>
                        <div style="text-align: center; margin: 15px 0;">
                            <strong>p â‰ˆ (1 - e<sup>-kn/m</sup>)<sup>k</sup></strong>
                        </div>
                        <p>
                            NumÄƒrul optim de funcÈ›ii hash: <strong>k = (m/n) Â· ln(2)</strong>
                        </p>
                    </div>
                    
                    <table style="font-size: 0.7em;">
                        <tr>
                            <th>m/n (biÈ›i/element)</th>
                            <th>k optim</th>
                            <th>False positive rate</th>
                        </tr>
                        <tr><td>8</td><td>6</td><td>2.2%</td></tr>
                        <tr><td>10</td><td>7</td><td>0.82%</td></tr>
                        <tr><td>12</td><td>8</td><td>0.31%</td></tr>
                        <tr><td>16</td><td>11</td><td>0.046%</td></tr>
                    </table>
                </section>
            </section>
            
            <!-- LAB -->
            <section>
                <h2>ğŸ”¬ Laborator: Graph Library</h2>
                
                <div class="diagram-box">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     POLYGLOT GRAPH LIBRARY                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   Python (Core Logic):                                                  â”‚
â”‚   â”œâ”€â”€ Graph class cu adjacency list                                     â”‚
â”‚   â”œâ”€â”€ BFS, DFS, Dijkstra, A*                                           â”‚
â”‚   â”œâ”€â”€ Cycle detection, topological sort                                â”‚
â”‚   â””â”€â”€ NetworkX integration                                             â”‚
â”‚                                                                         â”‚
â”‚   C++ (Performance):                                                    â”‚
â”‚   â”œâ”€â”€ Template Graph<Node, Edge>                                        â”‚
â”‚   â”œâ”€â”€ Priority queue optimization                                       â”‚
â”‚   â””â”€â”€ Cache-friendly adjacency list                                    â”‚
â”‚                                                                         â”‚
â”‚   JavaScript (Visualization):                                           â”‚
â”‚   â”œâ”€â”€ D3.js force-directed layout                                       â”‚
â”‚   â”œâ”€â”€ Interactive node/edge manipulation                               â”‚
â”‚   â””â”€â”€ Algorithm animation (step-by-step)                               â”‚
â”‚                                                                         â”‚
â”‚   Dataset: Romanian cities road network                                â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
                </div>
            </section>
            
            <!-- END -->
            <section data-background-gradient="linear-gradient(135deg, #0d1117 0%, #161b22 100%)">
                <h1>ÃntrebÄƒri?</h1>
                <p style="color: #8b949e;">
                    <strong>MIDTERM EXAM</strong> â€” SÄƒptÄƒmÃ¢na viitoare!<br>
                    Format: 2h practic, open-book, problemÄƒ nouÄƒ
                </p>
                <hr style="border-color: #30363d; margin: 30px 0;">
                <p style="font-size: 0.7em; color: #8b949e;">
                    ğŸ“§ antonio.clim@csie.ase.ro
                </p>
            </section>
            
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/math/math.js"></script>
    
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: 'c/t',
            transition: 'slide',
            plugins: [ RevealHighlight, RevealMath.KaTeX ]
        });
    </script>
</body>
</html>
