<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12UNIT: Web APIs and Data Acquisition</title>
    <style>
        :root {
            --primary: #1a365d;
            --secondary: #2c5282;
            --accent: #ed8936;
            --text: #2d3748;
            --light: #f7fafc;
            --code-bg: #1a202c;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--light);
            color: var(--text);
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 4rem;
            display: none;
            flex-direction: column;
        }
        
        .slide.active {
            display: flex;
        }
        
        .slide-title {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        .slide-title h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
        }
        
        .slide-title .subtitle {
            font-size: 1.5rem;
            opacity: 0.9;
        }
        
        .slide-content {
            background: white;
        }
        
        .slide-content h2 {
            color: var(--primary);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            border-bottom: 4px solid var(--accent);
            padding-bottom: 0.5rem;
        }
        
        .slide-content h3 {
            color: var(--secondary);
            font-size: 1.5rem;
            margin: 1.5rem 0 1rem;
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 1rem;
        }
        
        .content-box {
            background: var(--light);
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
        }
        
        .content-box h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        ul, ol {
            margin-left: 1.5rem;
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        pre {
            background: var(--code-bg);
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 1rem 0;
        }
        
        .inline-code {
            background: #edf2f7;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        
        th, td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
        }
        
        th {
            background: var(--primary);
            color: white;
        }
        
        tr:nth-child(even) {
            background: var(--light);
        }
        
        .navigation {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }
        
        .nav-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s;
        }
        
        .nav-btn:hover {
            background: var(--secondary);
        }
        
        .slide-counter {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .speaker-notes {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2d3748;
            color: white;
            padding: 1rem 2rem;
            display: none;
            font-size: 0.9rem;
        }
        
        .speaker-notes.visible {
            display: block;
        }
        
        .diagram {
            text-align: center;
            margin: 2rem 0;
        }
        
        .diagram svg {
            max-width: 100%;
            height: auto;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
        }
        
        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 2rem;
        }
        
        .callout {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            border-radius: 8px;
            padding: 1rem 1.5rem;
            margin: 1rem 0;
        }
        
        .callout-warning {
            background: #fffaf0;
            border-color: #fbd38d;
        }
        
        .callout-danger {
            background: #fff5f5;
            border-color: #feb2b2;
        }
        
        .callout-success {
            background: #f0fff4;
            border-color: #9ae6b4;
        }
        
        .callout h4 {
            color: var(--secondary);
            margin-bottom: 0.5rem;
        }
        
        .highlight {
            background: #fefcbf;
            padding: 0.2rem 0.4rem;
            border-radius: 2px;
        }
        
        @media (max-width: 1200px) {
            .slide {
                padding: 2rem;
            }
            .slide-title h1 {
                font-size: 2.5rem;
            }
            .content-grid, .two-column, .three-column {
                grid-template-columns: 1fr;
            }
        }
        
        @media print {
            .slide {
                page-break-after: always;
                display: flex !important;
                min-height: auto;
                padding: 2rem;
            }
            .navigation, .speaker-notes, .slide-counter {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- Slide 1: Title -->
    <section class="slide slide-title active" data-notes="Welcome to Unit 12. Today we explore how to programmatically acquire data from web sources.">
        <h1>12UNIT: Web APIs and Data Acquisition</h1>
        <p class="subtitle">Computational Thinking for Researchers</p>
        <p style="margin-top: 2rem; opacity: 0.8;">Dr Antonio Clim • Academy of Economic Studies, Bucharest</p>
    </section>

    <!-- Slide 2: Learning Objectives -->
    <section class="slide slide-content" data-notes="These are our learning objectives. By the end of this unit, you should be able to perform all of these tasks independently.">
        <h2>Learning Objectives</h2>
        <ol>
            <li><strong>Understand</strong> HTTP methods, status codes, headers and REST principles</li>
            <li><strong>Apply</strong> API consumption using <code class="inline-code">requests</code>: GET, POST, authentication</li>
            <li><strong>Apply</strong> Web scraping with BeautifulSoup and ethical considerations</li>
            <li><strong>Apply</strong> Error handling, rate limiting and retry logic</li>
            <li><strong>Create</strong> Design and implement Flask REST APIs for research data</li>
            <li><strong>Evaluate</strong> Data acquisition strategies for research scenarios</li>
        </ol>
    </section>

    <!-- Slide 3: Why Web APIs Matter -->
    <section class="slide slide-content" data-notes="Modern research increasingly depends on programmatic data access. Manual data collection is no longer scalable.">
        <h2>Why Web APIs Matter for Research</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>Data at Scale</h4>
                <p>Bibliographic databases, government statistics, environmental monitoring — too much to collect manually.</p>
            </div>
            <div class="content-box">
                <h4>Reproducibility</h4>
                <p>Programmatic acquisition can be scripted, versioned and repeated exactly.</p>
            </div>
            <div class="content-box">
                <h4>Integration</h4>
                <p>Combine multiple data sources into unified analysis pipelines.</p>
            </div>
            <div class="content-box">
                <h4>Currency</h4>
                <p>Access real-time or frequently updated data without manual intervention.</p>
            </div>
        </div>
    </section>

    <!-- Slide 4: Unit Roadmap -->
    <section class="slide slide-content" data-notes="Here's our roadmap for this unit. We'll progress from fundamentals to practical application.">
        <h2>Unit Roadmap</h2>
        <div class="three-column">
            <div class="content-box">
                <h4>Part 1: Foundations</h4>
                <ul>
                    <li>HTTP Protocol</li>
                    <li>Request-Response Cycle</li>
                    <li>Methods and Status Codes</li>
                    <li>Headers and Content Types</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>Part 2: Consumption</h4>
                <ul>
                    <li>REST Principles</li>
                    <li>Authentication Patterns</li>
                    <li>Pagination Handling</li>
                    <li>Error Recovery</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>Part 3: Creation</h4>
                <ul>
                    <li>Web Scraping Ethics</li>
                    <li>BeautifulSoup</li>
                    <li>Flask API Design</li>
                    <li>Testing APIs</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Slide 5: HTTP Fundamentals -->
    <section class="slide slide-content" data-notes="HTTP is the foundation of web communication. Understanding its structure is essential for effective API use.">
        <h2>HTTP: The Foundation</h2>
        <div class="two-column">
            <div>
                <h3>Request-Response Cycle</h3>
                <ul>
                    <li><strong>Client</strong> sends request with method, URL, headers, body</li>
                    <li><strong>Server</strong> processes and returns status, headers, body</li>
                    <li><strong>Stateless</strong> — each request is independent</li>
                </ul>
                <h3>Key Properties</h3>
                <ul>
                    <li>Text-based protocol</li>
                    <li>Layered on TCP/IP</li>
                    <li>Extensible via headers</li>
                </ul>
            </div>
            <div>
                <pre><code>GET /api/works/123 HTTP/1.1
Host: api.example.com
Accept: application/json
Authorization: Bearer token123

---

HTTP/1.1 200 OK
Content-Type: application/json

{"id": 123, "title": "..."}</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 6: HTTP Methods Overview -->
    <section class="slide slide-content" data-notes="HTTP methods express intent. Using the correct method is essential for RESTful design.">
        <h2>HTTP Methods Overview</h2>
        <table>
            <tr>
                <th>Method</th>
                <th>Purpose</th>
                <th>Idempotent</th>
                <th>Safe</th>
                <th>Body</th>
            </tr>
            <tr>
                <td><strong>GET</strong></td>
                <td>Retrieve resource</td>
                <td>✓</td>
                <td>✓</td>
                <td>No</td>
            </tr>
            <tr>
                <td><strong>POST</strong></td>
                <td>Create resource</td>
                <td>✗</td>
                <td>✗</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><strong>PUT</strong></td>
                <td>Replace resource</td>
                <td>✓</td>
                <td>✗</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><strong>PATCH</strong></td>
                <td>Partial update</td>
                <td>✗</td>
                <td>✗</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><strong>DELETE</strong></td>
                <td>Remove resource</td>
                <td>✓</td>
                <td>✗</td>
                <td>Optional</td>
            </tr>
        </table>
        <div class="callout">
            <h4>Idempotent</h4>
            <p>Multiple identical requests produce the same result as a single request. Critical for retry logic!</p>
        </div>
    </section>

    <!-- Slide 7: GET Method Deep Dive -->
    <section class="slide slide-content" data-notes="GET is the most common method for data acquisition. Master it thoroughly.">
        <h2>GET Method: Deep Dive</h2>
        <div class="two-column">
            <div>
                <h3>Characteristics</h3>
                <ul>
                    <li>Retrieves data without side effects</li>
                    <li>Parameters passed via URL query string</li>
                    <li>Responses can be cached</li>
                    <li>Should never modify server state</li>
                </ul>
                <h3>URL Structure</h3>
                <pre><code>https://api.example.com/works?
  topic=machine+learning&
  year=2024&
  limit=25</code></pre>
            </div>
            <div>
                <h3>Python Implementation</h3>
                <pre><code>import requests

response = requests.get(
    'https://api.example.com/works',
    params={
        'topic': 'machine learning',
        'year': 2024,
        'limit': 25
    },
    timeout=30
)

data = response.json()</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 8: POST Method Deep Dive -->
    <section class="slide slide-content" data-notes="POST creates new resources. Understanding the request body format is essential.">
        <h2>POST Method: Deep Dive</h2>
        <div class="two-column">
            <div>
                <h3>Characteristics</h3>
                <ul>
                    <li>Creates new resources</li>
                    <li>Data sent in request body</li>
                    <li>Not idempotent (each call creates new resource)</li>
                    <li>Returns 201 Created on success</li>
                </ul>
                <h3>Content Types</h3>
                <ul>
                    <li><code class="inline-code">application/json</code> — Most common</li>
                    <li><code class="inline-code">application/x-www-form-urlencoded</code></li>
                    <li><code class="inline-code">multipart/form-data</code> — File uploads</li>
                </ul>
            </div>
            <div>
                <pre><code>import requests

response = requests.post(
    'https://api.example.com/datasets',
    json={
        'name': 'Climate Analysis 2024',
        'description': 'Temperature data',
        'format': 'CSV'
    },
    headers={
        'Authorization': 'Bearer token123'
    },
    timeout=30
)

if response.status_code == 201:
    new_resource = response.json()
    print(f"Created: {new_resource['id']}")</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 9: HTTP Status Codes -->
    <section class="slide slide-content" data-notes="Status codes tell you what happened. Learn to interpret them for effective error handling.">
        <h2>HTTP Status Codes</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>2xx Success</h4>
                <ul>
                    <li><strong>200</strong> OK — Standard success</li>
                    <li><strong>201</strong> Created — Resource created</li>
                    <li><strong>202</strong> Accepted — Async processing</li>
                    <li><strong>204</strong> No Content — Success, no body</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>4xx Client Error</h4>
                <ul>
                    <li><strong>400</strong> Bad Request — Invalid syntax</li>
                    <li><strong>401</strong> Unauthorised — Auth required</li>
                    <li><strong>403</strong> Forbidden — Permission denied</li>
                    <li><strong>404</strong> Not Found — Resource missing</li>
                    <li><strong>429</strong> Too Many Requests — Rate limited</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>5xx Server Error</h4>
                <ul>
                    <li><strong>500</strong> Internal Error — Server failure</li>
                    <li><strong>502</strong> Bad Gateway — Upstream error</li>
                    <li><strong>503</strong> Service Unavailable — Overloaded</li>
                    <li><strong>504</strong> Gateway Timeout — Upstream timeout</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>Retry Logic</h4>
                <ul>
                    <li><strong>4xx</strong> — Usually do NOT retry (client error)</li>
                    <li><strong>429</strong> — Retry after delay</li>
                    <li><strong>5xx</strong> — Retry with backoff</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Slide 10: HTTP Headers -->
    <section class="slide slide-content" data-notes="Headers carry metadata about the request and response. Several are essential for API work.">
        <h2>Essential HTTP Headers</h2>
        <div class="two-column">
            <div>
                <h3>Request Headers</h3>
                <table>
                    <tr>
                        <td><code>Accept</code></td>
                        <td>Desired response format</td>
                    </tr>
                    <tr>
                        <td><code>Authorization</code></td>
                        <td>Authentication credentials</td>
                    </tr>
                    <tr>
                        <td><code>Content-Type</code></td>
                        <td>Request body format</td>
                    </tr>
                    <tr>
                        <td><code>User-Agent</code></td>
                        <td>Client identification</td>
                    </tr>
                </table>
            </div>
            <div>
                <h3>Response Headers</h3>
                <table>
                    <tr>
                        <td><code>Content-Type</code></td>
                        <td>Response body format</td>
                    </tr>
                    <tr>
                        <td><code>X-RateLimit-*</code></td>
                        <td>Rate limit information</td>
                    </tr>
                    <tr>
                        <td><code>Link</code></td>
                        <td>Pagination links</td>
                    </tr>
                    <tr>
                        <td><code>Retry-After</code></td>
                        <td>When to retry (429/503)</td>
                    </tr>
                </table>
            </div>
        </div>
        <pre><code>headers = {
    'Accept': 'application/json',
    'Authorization': 'Bearer your-token-here',
    'User-Agent': 'ResearchBot/1.0 (contact@university.edu)'
}</code></pre>
    </section>

    <!-- Slide 11: REST Principles -->
    <section class="slide slide-content" data-notes="REST is an architectural style, not a specification. Understanding its principles helps you work with any API.">
        <h2>REST Architectural Principles</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>Resource-Oriented</h4>
                <p>Everything is a resource with a unique URI. Resources are nouns, methods are verbs.</p>
                <code class="inline-code">/api/publications/123</code>
            </div>
            <div class="content-box">
                <h4>Stateless</h4>
                <p>Each request contains all information needed. Server maintains no client state between requests.</p>
            </div>
            <div class="content-box">
                <h4>Uniform Interface</h4>
                <p>Standard methods (GET, POST, etc.) with predictable semantics across all resources.</p>
            </div>
            <div class="content-box">
                <h4>HATEOAS</h4>
                <p>Hypermedia as the Engine of Application State — responses include links to related resources.</p>
            </div>
        </div>
    </section>

    <!-- Slide 12: RESTful URL Design -->
    <section class="slide slide-content" data-notes="Good URL design makes APIs intuitive. Follow these conventions.">
        <h2>RESTful URL Design</h2>
        <table>
            <tr>
                <th>Pattern</th>
                <th>Example</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>Collection</td>
                <td><code>/api/publications</code></td>
                <td>List of resources</td>
            </tr>
            <tr>
                <td>Item</td>
                <td><code>/api/publications/123</code></td>
                <td>Single resource</td>
            </tr>
            <tr>
                <td>Nested</td>
                <td><code>/api/authors/42/publications</code></td>
                <td>Related collection</td>
            </tr>
            <tr>
                <td>Filtered</td>
                <td><code>/api/publications?year=2024</code></td>
                <td>Query parameters</td>
            </tr>
            <tr>
                <td>Versioned</td>
                <td><code>/api/v2/publications</code></td>
                <td>API version in path</td>
            </tr>
        </table>
        <div class="callout">
            <h4>Best Practices</h4>
            <p>Use plural nouns, lowercase, hyphens for multi-word. Avoid verbs in URLs — the HTTP method provides the action.</p>
        </div>
    </section>

    <!-- Slide 13: Authentication Overview -->
    <section class="slide slide-content" data-notes="Different APIs use different authentication methods. Know how to handle each.">
        <h2>Authentication Patterns</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>API Keys</h4>
                <p>Simple token in header or query parameter. Easy to implement, but limited security.</p>
                <code class="inline-code">X-API-Key: abc123</code>
            </div>
            <div class="content-box">
                <h4>Basic Auth</h4>
                <p>Username:password encoded in Base64. Only use over HTTPS.</p>
                <code class="inline-code">Authorization: Basic dXNlcjpwYXNz</code>
            </div>
            <div class="content-box">
                <h4>Bearer Tokens</h4>
                <p>Token obtained from auth flow. Most common for modern APIs.</p>
                <code class="inline-code">Authorization: Bearer eyJhbG...</code>
            </div>
            <div class="content-box">
                <h4>OAuth 2.0</h4>
                <p>Delegated authorisation. User grants specific permissions without sharing password.</p>
            </div>
        </div>
    </section>

    <!-- Slide 14: API Key Authentication -->
    <section class="slide slide-content" data-notes="API keys are simple but require careful handling. Never commit them to version control.">
        <h2>API Key Authentication</h2>
        <div class="two-column">
            <div>
                <h3>Header Method (Preferred)</h3>
                <pre><code>import os
import requests

API_KEY = os.environ['MY_API_KEY']

response = requests.get(
    'https://api.example.com/data',
    headers={
        'X-API-Key': API_KEY
    }
)</code></pre>
            </div>
            <div>
                <h3>Query Parameter Method</h3>
                <pre><code>response = requests.get(
    'https://api.example.com/data',
    params={
        'apikey': API_KEY
    }
)

# Less secure: key visible in logs
# and browser history</code></pre>
            </div>
        </div>
        <div class="callout-warning callout">
            <h4>Security Warning</h4>
            <p>Never hardcode API keys in source files. Use environment variables or secure credential stores.</p>
        </div>
    </section>

    <!-- Slide 15: OAuth 2.0 Flow -->
    <section class="slide slide-content" data-notes="OAuth2 is complex but powerful. Understand the flow to work with modern APIs.">
        <h2>OAuth 2.0 Authorisation Flow</h2>
        <div class="two-column">
            <div>
                <h3>Flow Steps</h3>
                <ol>
                    <li>Redirect user to authorisation URL</li>
                    <li>User grants permissions</li>
                    <li>Receive authorisation code</li>
                    <li>Exchange code for access token</li>
                    <li>Use token for API requests</li>
                    <li>Refresh token when expired</li>
                </ol>
            </div>
            <div>
                <pre><code># Step 4: Exchange code for token
token_response = requests.post(
    'https://auth.example.com/token',
    data={
        'grant_type': 'authorization_code',
        'code': auth_code,
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET,
        'redirect_uri': REDIRECT_URI
    }
)

access_token = token_response.json()['access_token']</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 16: Pagination Overview -->
    <section class="slide slide-content" data-notes="APIs paginate large result sets. You must handle pagination to get complete data.">
        <h2>Pagination Patterns</h2>
        <div class="three-column">
            <div class="content-box">
                <h4>Offset-Based</h4>
                <p>Skip N records, return M</p>
                <code class="inline-code">?offset=100&limit=25</code>
                <p style="margin-top:0.5rem;font-size:0.9rem;">Simple but inefficient for large offsets</p>
            </div>
            <div class="content-box">
                <h4>Cursor-Based</h4>
                <p>Opaque token pointing to position</p>
                <code class="inline-code">?cursor=eyJpZCI6MTIzfQ</code>
                <p style="margin-top:0.5rem;font-size:0.9rem;">Efficient, stable under changes</p>
            </div>
            <div class="content-box">
                <h4>Link Headers</h4>
                <p>URLs in response headers</p>
                <code class="inline-code">Link: &lt;...&gt;; rel="next"</code>
                <p style="margin-top:0.5rem;font-size:0.9rem;">HATEOAS-compliant</p>
            </div>
        </div>
    </section>

    <!-- Slide 17: Pagination Implementation -->
    <section class="slide slide-content" data-notes="Here's how to implement pagination collection in Python.">
        <h2>Implementing Pagination</h2>
        <pre><code>def fetch_all_records(base_url: str, max_records: int = 1000) -> list[dict]:
    """Fetch all records handling pagination."""
    records = []
    url = base_url
    
    while url and len(records) < max_records:
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        
        data = response.json()
        records.extend(data['results'])
        
        # Check for next page
        # Method 1: Link headers
        if 'next' in response.links:
            url = response.links['next']['url']
        # Method 2: JSON response
        elif data.get('meta', {}).get('next_cursor'):
            url = f"{base_url}?cursor={data['meta']['next_cursor']}"
        else:
            url = None
    
    return records[:max_records]</code></pre>
    </section>

    <!-- Slide 18: Rate Limiting -->
    <section class="slide slide-content" data-notes="APIs limit request rates to protect their servers. Respecting limits is essential.">
        <h2>Rate Limiting</h2>
        <div class="two-column">
            <div>
                <h3>Why Rate Limits Exist</h3>
                <ul>
                    <li>Prevent server overload</li>
                    <li>Ensure fair access for all users</li>
                    <li>Protect against abuse</li>
                </ul>
                <h3>Typical Limits</h3>
                <ul>
                    <li>CrossRef: 50 requests/second</li>
                    <li>OpenAlex: 100K requests/day</li>
                    <li>Twitter/X: 450 requests/15min</li>
                </ul>
            </div>
            <div>
                <h3>Rate Limit Headers</h3>
                <pre><code>X-RateLimit-Limit: 100
X-RateLimit-Remaining: 47
X-RateLimit-Reset: 1705590000</code></pre>
                <h3>Handling 429 Response</h3>
                <pre><code>if response.status_code == 429:
    retry_after = int(
        response.headers.get(
            'Retry-After', 60
        )
    )
    time.sleep(retry_after)</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 19: Exponential Backoff -->
    <section class="slide slide-content" data-notes="Exponential backoff prevents thundering herd problems when recovering from failures.">
        <h2>Exponential Backoff</h2>
        <div class="two-column">
            <div>
                <h3>The Pattern</h3>
                <p>Wait time increases exponentially with each retry:</p>
                <ul>
                    <li>Attempt 1: immediate</li>
                    <li>Attempt 2: wait 1 second</li>
                    <li>Attempt 3: wait 2 seconds</li>
                    <li>Attempt 4: wait 4 seconds</li>
                    <li>Attempt 5: wait 8 seconds</li>
                </ul>
                <p>Add jitter (random delay) to prevent synchronised retries.</p>
            </div>
            <div>
                <pre><code>import random
import time

def request_with_backoff(url, max_retries=5):
    for attempt in range(max_retries):
        try:
            response = requests.get(url)
            response.raise_for_status()
            return response
        except requests.RequestException as e:
            if attempt == max_retries - 1:
                raise
            
            # Exponential backoff with jitter
            delay = (2 ** attempt) + random.random()
            time.sleep(delay)</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 20: Python requests Library -->
    <section class="slide slide-content" data-notes="The requests library is Python's standard for HTTP. Master its features.">
        <h2>Python requests Library</h2>
        <pre><code>import requests

# Create a session for connection reuse
session = requests.Session()
session.headers.update({
    'User-Agent': 'ResearchBot/1.0',
    'Accept': 'application/json'
})

# Configure retry strategy
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter

retry_strategy = Retry(
    total=3,
    backoff_factor=1,
    status_forcelist=[429, 500, 502, 503, 504]
)
adapter = HTTPAdapter(max_retries=retry_strategy)
session.mount('https://', adapter)

# Make request with timeout
response = session.get('https://api.example.com/data', timeout=30)</code></pre>
    </section>

    <!-- Slide 21: Web Scraping Introduction -->
    <section class="slide slide-content" data-notes="When APIs aren't available, scraping may be necessary. But proceed with caution.">
        <h2>Web Scraping: When and Why</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>Use Scraping When</h4>
                <ul>
                    <li>No API is available</li>
                    <li>API lacks needed data</li>
                    <li>Historical data collection</li>
                    <li>Price/availability monitoring</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>Prefer APIs When</h4>
                <ul>
                    <li>Official API exists</li>
                    <li>Structured data needed</li>
                    <li>Long-term reliability important</li>
                    <li>Rate limits are clear</li>
                </ul>
            </div>
        </div>
        <div class="callout-warning callout">
            <h4>Legal Considerations</h4>
            <p>Always check robots.txt and terms of service. Respect rate limits. Consider whether the data is copyrighted.</p>
        </div>
    </section>

    <!-- Slide 22: Scraping Ethics -->
    <section class="slide slide-content" data-notes="Ethical scraping is essential. Your institution's reputation depends on responsible conduct.">
        <h2>Scraping Ethics and Best Practices</h2>
        <div class="two-column">
            <div>
                <h3>Do</h3>
                <ul>
                    <li>Check robots.txt first</li>
                    <li>Identify yourself in User-Agent</li>
                    <li>Respect rate limits (1 req/sec default)</li>
                    <li>Cache responses locally</li>
                    <li>Scrape during off-peak hours</li>
                    <li>Contact site owners if unclear</li>
                </ul>
            </div>
            <div>
                <h3>Don't</h3>
                <ul>
                    <li>Ignore robots.txt directives</li>
                    <li>Hammer servers with requests</li>
                    <li>Bypass authentication</li>
                    <li>Scrape personal/private data</li>
                    <li>Violate terms of service</li>
                    <li>Redistribute copyrighted content</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Slide 23: robots.txt -->
    <section class="slide slide-content" data-notes="robots.txt tells crawlers what they may access. Always check it first.">
        <h2>Understanding robots.txt</h2>
        <div class="two-column">
            <div>
                <h3>Example robots.txt</h3>
                <pre><code>User-agent: *
Disallow: /admin/
Disallow: /private/
Crawl-delay: 10

User-agent: ResearchBot
Allow: /public/
Disallow: /</code></pre>
            </div>
            <div>
                <h3>Parsing in Python</h3>
                <pre><code>from urllib.robotparser import RobotFileParser

rp = RobotFileParser()
rp.set_url('https://example.com/robots.txt')
rp.read()

# Check if allowed
if rp.can_fetch('ResearchBot', '/data/'):
    # Proceed with scraping
    pass
else:
    print("Scraping not allowed")</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 24: BeautifulSoup Basics -->
    <section class="slide slide-content" data-notes="BeautifulSoup makes HTML parsing accessible. Learn its selector syntax.">
        <h2>BeautifulSoup Fundamentals</h2>
        <pre><code>from bs4 import BeautifulSoup
import requests

response = requests.get('https://example.com/research')
soup = BeautifulSoup(response.content, 'html.parser')

# Find by tag
titles = soup.find_all('h2')

# Find by class
articles = soup.find_all('div', class_='article')

# Find by CSS selector
authors = soup.select('span.author-name')

# Find single element
main_content = soup.find('main', id='content')

# Extract text
for article in articles:
    title = article.find('h3').get_text(strip=True)
    link = article.find('a')['href']
    print(f"{title}: {link}")</code></pre>
    </section>

    <!-- Slide 25: BeautifulSoup Navigation -->
    <section class="slide slide-content" data-notes="Navigate the DOM tree to extract related content.">
        <h2>BeautifulSoup: DOM Navigation</h2>
        <div class="two-column">
            <div>
                <h3>Tree Navigation</h3>
                <pre><code># Parent
parent = element.parent

# Children
for child in element.children:
    process(child)

# Siblings
next_elem = element.find_next_sibling()
prev_elem = element.find_previous_sibling()

# Descendants
for desc in element.descendants:
    if desc.name == 'a':
        print(desc['href'])</code></pre>
            </div>
            <div>
                <h3>Extracting Data</h3>
                <pre><code># Get text
text = element.get_text()
text = element.get_text(strip=True)

# Get attribute
href = link['href']
href = link.get('href', '')

# Get all attributes
attrs = element.attrs

# Check if attribute exists
if 'data-id' in element.attrs:
    id = element['data-id']</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 26: Flask Introduction -->
    <section class="slide slide-content" data-notes="Flask lets you create your own APIs to share research data with colleagues.">
        <h2>Flask: Building Your Own APIs</h2>
        <div class="two-column">
            <div>
                <h3>Why Build APIs?</h3>
                <ul>
                    <li>Share processed data with collaborators</li>
                    <li>Create unified interface over multiple sources</li>
                    <li>Enable automated workflows</li>
                    <li>Control access to sensitive data</li>
                </ul>
            </div>
            <div>
                <h3>Minimal Flask App</h3>
                <pre><code>from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/health')
def health():
    return jsonify({
        'status': 'healthy'
    })

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 27: Flask Routes -->
    <section class="slide slide-content" data-notes="Routes map URLs to handler functions. Design them RESTfully.">
        <h2>Flask Routes and Methods</h2>
        <pre><code>from flask import Flask, jsonify, request, abort

app = Flask(__name__)
datasets = {}  # In-memory storage

@app.route('/api/datasets', methods=['GET'])
def list_datasets():
    """List all datasets with optional filtering."""
    # Get query parameters
    format_filter = request.args.get('format')
    
    results = list(datasets.values())
    if format_filter:
        results = [d for d in results if d['format'] == format_filter]
    
    return jsonify({
        'data': results,
        'count': len(results)
    })

@app.route('/api/datasets/&lt;int:dataset_id&gt;', methods=['GET'])
def get_dataset(dataset_id: int):
    """Get single dataset by ID."""
    dataset = datasets.get(dataset_id)
    if not dataset:
        abort(404, description='Dataset not found')
    return jsonify(dataset)</code></pre>
    </section>

    <!-- Slide 28: Flask POST and Validation -->
    <section class="slide slide-content" data-notes="POST endpoints create resources. Always validate input data.">
        <h2>Creating Resources with POST</h2>
        <pre><code>@app.route('/api/datasets', methods=['POST'])
def create_dataset():
    """Create new dataset."""
    # Validate content type
    if not request.is_json:
        abort(400, description='Request must be JSON')
    
    data = request.get_json()
    
    # Validate required fields
    required = ['name', 'description', 'format']
    missing = [f for f in required if f not in data]
    if missing:
        abort(400, description=f'Missing fields: {missing}')
    
    # Create resource
    dataset_id = len(datasets) + 1
    new_dataset = {
        'id': dataset_id,
        'name': data['name'],
        'description': data['description'],
        'format': data['format'],
        'created_at': datetime.utcnow().isoformat() + 'Z'
    }
    datasets[dataset_id] = new_dataset
    
    return jsonify(new_dataset), 201  # 201 Created</code></pre>
    </section>

    <!-- Slide 29: Flask Error Handlers -->
    <section class="slide slide-content" data-notes="Consistent error responses make APIs easier to use.">
        <h2>Flask Error Handling</h2>
        <pre><code>@app.errorhandler(400)
def bad_request(error):
    return jsonify({
        'error': 'Bad Request',
        'message': str(error.description),
        'status': 400
    }), 400

@app.errorhandler(404)
def not_found(error):
    return jsonify({
        'error': 'Not Found',
        'message': str(error.description),
        'status': 404
    }), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({
        'error': 'Internal Server Error',
        'message': 'An unexpected error occurred',
        'status': 500
    }), 500

# Generic exception handler
@app.errorhandler(Exception)
def handle_exception(e):
    app.logger.error(f"Unhandled exception: {e}")
    return jsonify({'error': 'Internal Server Error'}), 500</code></pre>
    </section>

    <!-- Slide 30: Flask Application Factory -->
    <section class="slide slide-content" data-notes="The factory pattern makes Flask apps testable and configurable.">
        <h2>Application Factory Pattern</h2>
        <pre><code>from flask import Flask

def create_app(config=None):
    """Create Flask application."""
    app = Flask(__name__)
    
    # Load configuration
    app.config.from_mapping(
        SECRET_KEY='dev',
        DATABASE='app.db'
    )
    if config:
        app.config.from_mapping(config)
    
    # Register blueprints
    from . import api
    app.register_blueprint(api.bp)
    
    # Register error handlers
    register_error_handlers(app)
    
    return app

# Usage:
# Production: create_app({'SECRET_KEY': os.environ['SECRET_KEY']})
# Testing: create_app({'TESTING': True})</code></pre>
    </section>

    <!-- Slide 31: Testing APIs -->
    <section class="slide slide-content" data-notes="Testing ensures your API works correctly. Use pytest and Flask's test client.">
        <h2>Testing Flask APIs</h2>
        <pre><code>import pytest
from app import create_app

@pytest.fixture
def client():
    """Create test client."""
    app = create_app({'TESTING': True})
    with app.test_client() as client:
        yield client

def test_health_endpoint(client):
    """Test health check returns 200."""
    response = client.get('/api/health')
    assert response.status_code == 200
    assert response.json['status'] == 'healthy'

def test_create_dataset(client):
    """Test dataset creation."""
    response = client.post('/api/datasets',
        json={'name': 'Test', 'description': 'Test data', 'format': 'CSV'}
    )
    assert response.status_code == 201
    assert 'id' in response.json

def test_missing_required_field(client):
    """Test validation error."""
    response = client.post('/api/datasets', json={'name': 'Test'})
    assert response.status_code == 400</code></pre>
    </section>

    <!-- Slide 32: Research APIs in Practice -->
    <section class="slide slide-content" data-notes="Let's look at real APIs you'll use in research.">
        <h2>Research APIs in Practice</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>CrossRef</h4>
                <p>Bibliographic metadata for 130M+ works</p>
                <code class="inline-code">api.crossref.org/works</code>
            </div>
            <div class="content-box">
                <h4>OpenAlex</h4>
                <p>Open scholarly knowledge graph</p>
                <code class="inline-code">api.openalex.org</code>
            </div>
            <div class="content-box">
                <h4>Semantic Scholar</h4>
                <p>AI-powered paper search and analysis</p>
                <code class="inline-code">api.semanticscholar.org</code>
            </div>
            <div class="content-box">
                <h4>World Bank</h4>
                <p>Economic indicators and statistics</p>
                <code class="inline-code">api.worldbank.org</code>
            </div>
        </div>
    </section>

    <!-- Slide 33: OpenAlex Example -->
    <section class="slide slide-content" data-notes="OpenAlex is an excellent free API for bibliometric research.">
        <h2>OpenAlex API Example</h2>
        <pre><code>import requests

def search_publications(topic: str, limit: int = 25) -> list[dict]:
    """Search OpenAlex for publications on a topic."""
    
    response = requests.get(
        'https://api.openalex.org/works',
        params={
            'search': topic,
            'per_page': limit,
            'sort': 'cited_by_count:desc'
        },
        headers={
            'User-Agent': 'mailto:researcher@university.edu'
        },
        timeout=30
    )
    response.raise_for_status()
    
    results = []
    for work in response.json()['results']:
        results.append({
            'title': work['title'],
            'year': work['publication_year'],
            'citations': work['cited_by_count'],
            'doi': work.get('doi')
        })
    return results

# Usage
papers = search_publications('machine learning climate', limit=10)</code></pre>
    </section>

    <!-- Slide 34: Data Pipeline Architecture -->
    <section class="slide slide-content" data-notes="Combine acquisition, processing, and serving into a complete pipeline.">
        <h2>Complete Data Pipeline</h2>
        <div class="two-column">
            <div>
                <h3>Architecture</h3>
                <ol>
                    <li><strong>Acquisition</strong>: Fetch from external APIs</li>
                    <li><strong>Processing</strong>: Clean and transform data</li>
                    <li><strong>Storage</strong>: Cache locally or in database</li>
                    <li><strong>Serving</strong>: Expose via your own API</li>
                </ol>
                <h3>Benefits</h3>
                <ul>
                    <li>Insulates consumers from source changes</li>
                    <li>Enables caching and rate limit management</li>
                    <li>Adds custom filtering and aggregation</li>
                </ul>
            </div>
            <div style="text-align:center;">
                <pre style="display:inline-block;text-align:left;">
┌─────────────┐
│ External    │
│ APIs        │
└──────┬──────┘
       │ fetch
       ▼
┌─────────────┐
│ Acquisition │
│ Layer       │
└──────┬──────┘
       │ raw data
       ▼
┌─────────────┐
│ Processing  │
│ Layer       │
└──────┬──────┘
       │ clean data
       ▼
┌─────────────┐
│ Your Flask  │
│ API         │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Consumers   │
└─────────────┘
                </pre>
            </div>
        </div>
    </section>

    <!-- Slide 35: Caching Strategies -->
    <section class="slide slide-content" data-notes="Caching reduces API load and improves performance. Implement it early.">
        <h2>Caching Strategies</h2>
        <div class="two-column">
            <div>
                <h3>Why Cache?</h3>
                <ul>
                    <li>Reduce API calls (respect rate limits)</li>
                    <li>Faster response times</li>
                    <li>Work offline during development</li>
                    <li>Reproducibility of analysis</li>
                </ul>
                <h3>Cache Invalidation</h3>
                <ul>
                    <li>Time-based (TTL)</li>
                    <li>Version-based (ETag)</li>
                    <li>Manual refresh endpoint</li>
                </ul>
            </div>
            <div>
                <pre><code>import hashlib
import json
from pathlib import Path

def cached_request(url, params, cache_dir):
    """Make request with file-based caching."""
    # Generate cache key
    key = hashlib.md5(
        f"{url}{json.dumps(params)}".encode()
    ).hexdigest()
    cache_file = cache_dir / f"{key}.json"
    
    # Return cached if exists
    if cache_file.exists():
        return json.loads(cache_file.read_text())
    
    # Fetch and cache
    response = requests.get(url, params=params)
    response.raise_for_status()
    data = response.json()
    
    cache_file.write_text(json.dumps(data))
    return data</code></pre>
            </div>
        </div>
    </section>

    <!-- Slide 36: Security Best Practices -->
    <section class="slide slide-content" data-notes="Security matters even for research APIs. Protect your credentials and data.">
        <h2>Security Best Practices</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>Credential Management</h4>
                <ul>
                    <li>Use environment variables</li>
                    <li>Never commit secrets to Git</li>
                    <li>Rotate keys periodically</li>
                    <li>Use .env files locally</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>HTTPS</h4>
                <ul>
                    <li>Always use HTTPS for APIs</li>
                    <li>Verify SSL certificates</li>
                    <li>Pin certificates if needed</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>Input Validation</h4>
                <ul>
                    <li>Validate all user input</li>
                    <li>Sanitise before database queries</li>
                    <li>Use parameterised queries</li>
                </ul>
            </div>
            <div class="content-box">
                <h4>Logging</h4>
                <ul>
                    <li>Never log credentials</li>
                    <li>Mask sensitive data</li>
                    <li>Audit access patterns</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Slide 37: Common Mistakes -->
    <section class="slide slide-content" data-notes="Learn from common mistakes to write more reliable code.">
        <h2>Common Mistakes to Avoid</h2>
        <div class="two-column">
            <div class="content-box" style="border-color:#feb2b2;">
                <h4>❌ Bad Practices</h4>
                <ul>
                    <li>Hardcoding API keys</li>
                    <li>No timeout on requests</li>
                    <li>Ignoring rate limits</li>
                    <li>No retry logic</li>
                    <li>Not checking status codes</li>
                    <li>Blocking on slow APIs</li>
                </ul>
            </div>
            <div class="content-box" style="border-color:#9ae6b4;">
                <h4>✓ Good Practices</h4>
                <ul>
                    <li>Environment variables for secrets</li>
                    <li>Always set timeouts (30s default)</li>
                    <li>Track and respect rate limits</li>
                    <li>Exponential backoff on failures</li>
                    <li>Check response.raise_for_status()</li>
                    <li>Use async for multiple APIs</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Slide 38: Best Practices Summary -->
    <section class="slide slide-content" data-notes="Keep these best practices in mind for all your API work.">
        <h2>Best Practices Summary</h2>
        <div class="two-column">
            <div>
                <h3>API Consumption</h3>
                <ul>
                    <li>Use Sessions for multiple requests</li>
                    <li>Always set timeouts</li>
                    <li>Implement retry with backoff</li>
                    <li>Respect rate limits</li>
                    <li>Cache responses when appropriate</li>
                    <li>Store credentials securely</li>
                    <li>Include contact in User-Agent</li>
                </ul>
            </div>
            <div>
                <h3>API Design</h3>
                <ul>
                    <li>Use nouns for resources</li>
                    <li>Return appropriate status codes</li>
                    <li>Validate all input</li>
                    <li>Provide informative errors</li>
                    <li>Document endpoints clearly</li>
                    <li>Version your API</li>
                    <li>Support pagination</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Slide 39: Laboratory Overview -->
    <section class="slide slide-content" data-notes="Two laboratory sessions will reinforce these concepts with hands-on practice.">
        <h2>Laboratory Exercises</h2>
        <div class="content-grid">
            <div class="content-box">
                <h4>Lab 12.01: API Consumption (50 min)</h4>
                <ol>
                    <li>HTTP Fundamentals</li>
                    <li>REST Patterns and Pagination</li>
                    <li>Authentication Mechanisms</li>
                    <li>Research API Integration</li>
                    <li>Reliable Client Implementation</li>
                </ol>
            </div>
            <div class="content-box">
                <h4>Lab 12.02: Scraping & Flask (40 min)</h4>
                <ol>
                    <li>Web Scraping Fundamentals</li>
                    <li>Advanced Scraping Patterns</li>
                    <li>Flask API Development</li>
                    <li>Research Data API</li>
                </ol>
            </div>
        </div>
    </section>

    <!-- Slide 40: Key Takeaways -->
    <section class="slide slide-content" data-notes="Remember these key points as you work with web APIs.">
        <h2>Key Takeaways</h2>
        <div class="three-column">
            <div class="content-box">
                <h4>HTTP Mastery</h4>
                <p>Understand methods, status codes, and headers. They are your debugging tools.</p>
            </div>
            <div class="content-box">
                <h4>Reliability Patterns</h4>
                <p>Timeouts, retries, and backoff are not optional. Networks fail.</p>
            </div>
            <div class="content-box">
                <h4>Ethics First</h4>
                <p>Respect rate limits, robots.txt, and terms of service. Your reputation matters.</p>
            </div>
        </div>
        <div class="callout-success callout" style="margin-top:2rem;">
            <h4>Next Steps</h4>
            <p>Complete the laboratories, then tackle the homework assignment to build a complete data pipeline.</p>
        </div>
    </section>

    <!-- Slide 41: Questions -->
    <section class="slide slide-title" data-notes="Time for questions. What would you like to explore further?">
        <h1>Questions?</h1>
        <p class="subtitle">Let's discuss before we move to the laboratory</p>
    </section>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-btn" onclick="prevSlide()">← Previous</button>
        <button class="nav-btn" onclick="nextSlide()">Next →</button>
        <button class="nav-btn" onclick="toggleNotes()">Notes</button>
    </div>
    
    <div class="slide-counter">
        <span id="current">1</span> / <span id="total">41</span>
    </div>
    
    <div class="speaker-notes" id="notes"></div>

    <script>
        const slides = document.querySelectorAll('.slide');
        const notesPanel = document.getElementById('notes');
        const currentSpan = document.getElementById('current');
        const totalSpan = document.getElementById('total');
        let currentSlide = 0;
        
        totalSpan.textContent = slides.length;
        
        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + slides.length) % slides.length;
            slides[currentSlide].classList.add('active');
            currentSpan.textContent = currentSlide + 1;
            
            const notes = slides[currentSlide].dataset.notes || '';
            notesPanel.textContent = notes;
        }
        
        function nextSlide() { showSlide(currentSlide + 1); }
        function prevSlide() { showSlide(currentSlide - 1); }
        function toggleNotes() { notesPanel.classList.toggle('visible'); }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
            if (e.key === 'n') toggleNotes();
        });
    </script>
</body>
</html>
