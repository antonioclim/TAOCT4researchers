@startuml solid_principles
!theme plain
skinparam backgroundColor transparent
skinparam defaultFontName "Segoe UI"

title SOLID Principles in Research Software

package "S - Single Responsibility" {
    class BadExample {
        +simulate()
        +save_to_csv()
        +plot_results()
        +log_progress()
        --
        Too many responsibilities!
    }
    
    class GoodModel {
        +simulate()
    }
    class GoodPersistence {
        +save_to_csv()
    }
    class GoodVisualisation {
        +plot_results()
    }
    class GoodLogging {
        +log_progress()
    }
    
    BadExample -[hidden]-> GoodModel
}

package "O - Open/Closed" {
    interface Simulable <<open for extension>> {
        +step(dt): None
    }
    
    class SimulationRunner <<closed for modification>> {
        +run(sim: Simulable)
    }
    
    class NewModel implements Simulable {
        +step(dt): None
    }
    
    SimulationRunner --> Simulable
    
    note bottom of NewModel
        New models extend
        without modifying runner
    end note
}

package "L - Liskov Substitution" {
    abstract class Model {
        +step(dt: float): None
        --
        Precondition: dt > 0
        Postcondition: state updated
    }
    
    class ValidSubtype extends Model {
        +step(dt: float): None
        --
        Honours contract
    }
    
    class InvalidSubtype extends Model {
        +step(dt: float): None
        --
        Raises exception for small dt
        (Violates LSP!)
    }
}

package "I - Interface Segregation" {
    interface FatInterface {
        +run()
        +pause()
        +stop()
        +visualise()
        +export()
        +validate()
    }
    
    interface Runnable {
        +run()
        +pause()
        +stop()
    }
    
    interface Visualisable {
        +visualise()
    }
    
    interface Exportable {
        +export()
    }
    
    FatInterface -[hidden]-> Runnable
    
    note bottom of Runnable
        Clients depend only on
        interfaces they use
    end note
}

package "D - Dependency Inversion" {
    class HighLevelModule {
        -dependency: Abstraction
    }
    
    interface Abstraction {
        +operation()
    }
    
    class LowLevelModule implements Abstraction {
        +operation()
    }
    
    HighLevelModule --> Abstraction
    
    note right of HighLevelModule
        Depends on abstraction
        not concretion
    end note
}

@enduml
