@startuml observer_pattern
!theme plain
skinparam backgroundColor transparent
skinparam defaultFontName "Segoe UI"

title Observer Pattern: Event-Driven Decoupling

package "Subject (Observable)" {
    abstract class Subject<T> {
        -observers: list[Observer[T]]
        --
        +attach(observer: Observer[T]): None
        +detach(observer: Observer[T]): None
        +notify(event: T): None
    }
}

package "Observer Interface" {
    interface Observer<T> <<Protocol>> {
        +update(subject: Subject[T], event: T): None
    }
}

package "Concrete Observers" {
    class LoggingObserver implements Observer {
        -logger: Logger
        --
        +update(subject, event): None
    }
    
    class MetricsCollector implements Observer {
        -metrics: dict
        --
        +update(subject, event): None
        +get_summary(): dict
    }
    
    class Visualiser implements Observer {
        -canvas: Canvas
        --
        +update(subject, event): None
        +render(): None
    }
}

Subject --> Observer : notifies

note right of Subject
    Maintains observer registry
    Broadcasts state changes
end note

note bottom of Observer
    Receives notifications
    Reacts to events
end note

== Sequence Diagram ==

participant "Simulation" as S
participant "Subject" as Sub
participant "Observer1" as O1
participant "Observer2" as O2

S -> Sub : state changes
activate Sub
Sub -> O1 : update(event)
activate O1
O1 --> Sub : acknowledged
deactivate O1
Sub -> O2 : update(event)
activate O2
O2 --> Sub : acknowledged
deactivate O2
deactivate Sub

note over S, O2
    Observers are notified in registration order
    Each observer processes the event independently
end note

@enduml
