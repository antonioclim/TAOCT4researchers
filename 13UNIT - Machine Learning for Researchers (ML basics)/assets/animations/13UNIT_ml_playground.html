<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Playground - Interactive Machine Learning Demo</title>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --accent: #4a9eff;
            --accent-secondary: #4ecdc4;
            --text: #eaeaea;
            --text-muted: #888;
            --success: #4CAF50;
            --warning: #ff9800;
            --error: #f44336;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        header h1 {
            color: var(--accent);
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header p {
            color: var(--text-muted);
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: var(--bg-secondary);
            border: 2px solid transparent;
            color: var(--text);
            cursor: pointer;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
        }
        
        .tab-btn:hover {
            border-color: var(--accent);
        }
        
        .tab-btn.active {
            background: var(--accent);
            color: var(--bg-primary);
        }
        
        .tab-content {
            display: none;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 20px;
        }
        
        .panel h3 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-muted);
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid #333;
            color: var(--text);
            border-radius: 4px;
            font-size: 1em;
        }
        
        button {
            padding: 12px 24px;
            background: var(--accent);
            border: none;
            color: var(--bg-primary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            margin-right: 10px;
            margin-top: 10px;
        }
        
        button:hover {
            background: var(--accent-secondary);
        }
        
        button.secondary {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
        }
        
        canvas {
            width: 100%;
            height: 400px;
            background: var(--bg-primary);
            border-radius: 8px;
            cursor: crosshair;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--accent);
        }
        
        .metric-card .label {
            font-size: 0.85em;
            color: var(--text-muted);
            margin-top: 5px;
        }
        
        .log {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85em;
        }
        
        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        
        .log-entry.success { color: var(--success); }
        .log-entry.warning { color: var(--warning); }
        .log-entry.error { color: var(--error); }
        
        .confusion-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            max-width: 250px;
            margin: 20px auto;
        }
        
        .cm-cell {
            padding: 15px;
            text-align: center;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .cm-cell.header {
            background: transparent;
            color: var(--text-muted);
            font-size: 0.85em;
        }
        
        .cm-cell.tn { background: rgba(76, 175, 80, 0.3); }
        .cm-cell.fp { background: rgba(244, 67, 54, 0.3); }
        .cm-cell.fn { background: rgba(244, 67, 54, 0.3); }
        .cm-cell.tp { background: rgba(76, 175, 80, 0.3); }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: var(--bg-primary);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
            transition: width 0.3s;
        }
        
        .slider-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: var(--accent);
            font-weight: bold;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
        }
        
        .instructions {
            background: rgba(74, 158, 255, 0.1);
            border-left: 4px solid var(--accent);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
        }
        
        .instructions h4 {
            margin-bottom: 10px;
        }
        
        .cluster-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .cluster-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .cluster-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† ML Playground</h1>
            <p>Interactive Machine Learning Demonstrations ‚Ä¢ UNIT 13</p>
        </header>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="showTab('classification')">Classification</button>
            <button class="tab-btn" onclick="showTab('regression')">Regression</button>
            <button class="tab-btn" onclick="showTab('clustering')">Clustering</button>
            <button class="tab-btn" onclick="showTab('overfitting')">Overfitting Demo</button>
            <button class="tab-btn" onclick="showTab('validation')">Cross-Validation</button>
        </div>
        
        <!-- Classification Tab -->
        <div id="classification" class="tab-content active">
            <div class="grid">
                <div class="panel">
                    <h3>üìä Data Canvas</h3>
                    <div class="instructions">
                        <h4>Instructions</h4>
                        <p>Click to add points. Left-click for Class 0 (blue), Right-click for Class 1 (orange).</p>
                    </div>
                    <canvas id="classCanvas" width="500" height="400"></canvas>
                    <button onclick="trainClassifier()">Train Model</button>
                    <button class="secondary" onclick="clearClassCanvas()">Clear</button>
                    <button class="secondary" onclick="generateClassData()">Generate Data</button>
                </div>
                <div class="panel">
                    <h3>‚öôÔ∏è Model Settings</h3>
                    <div class="control-group">
                        <label>Algorithm</label>
                        <select id="classAlgorithm">
                            <option value="logistic">Logistic Regression</option>
                            <option value="knn">k-Nearest Neighbours</option>
                            <option value="tree">Decision Tree</option>
                        </select>
                    </div>
                    <div class="control-group" id="knnKGroup">
                        <label>k (neighbours): <span class="slider-value" id="knnKValue">5</span></label>
                        <input type="range" id="knnK" min="1" max="15" value="5" oninput="updateSlider('knnK', 'knnKValue')">
                    </div>
                    <div class="control-group" id="treeDepthGroup">
                        <label>Max Depth: <span class="slider-value" id="treeDepthValue">3</span></label>
                        <input type="range" id="treeDepth" min="1" max="10" value="3" oninput="updateSlider('treeDepth', 'treeDepthValue')">
                    </div>
                    
                    <h3 style="margin-top: 30px;">üìà Metrics</h3>
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="value" id="classAccuracy">--</div>
                            <div class="label">Accuracy</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="classPrecision">--</div>
                            <div class="label">Precision</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="classRecall">--</div>
                            <div class="label">Recall</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="classF1">--</div>
                            <div class="label">F1 Score</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 30px;">Confusion Matrix</h3>
                    <div class="confusion-matrix">
                        <div class="cm-cell header"></div>
                        <div class="cm-cell header">Pred 0</div>
                        <div class="cm-cell header">Pred 1</div>
                        <div class="cm-cell header">Actual 0</div>
                        <div class="cm-cell tn" id="cmTN">-</div>
                        <div class="cm-cell fp" id="cmFP">-</div>
                        <div class="cm-cell header">Actual 1</div>
                        <div class="cm-cell fn" id="cmFN">-</div>
                        <div class="cm-cell tp" id="cmTP">-</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Regression Tab -->
        <div id="regression" class="tab-content">
            <div class="grid">
                <div class="panel">
                    <h3>üìä Regression Data</h3>
                    <div class="instructions">
                        <h4>Instructions</h4>
                        <p>Click to add data points. The model will fit a line/curve through the points.</p>
                    </div>
                    <canvas id="regCanvas" width="500" height="400"></canvas>
                    <button onclick="trainRegressor()">Fit Model</button>
                    <button class="secondary" onclick="clearRegCanvas()">Clear</button>
                    <button class="secondary" onclick="generateRegData()">Generate Data</button>
                </div>
                <div class="panel">
                    <h3>‚öôÔ∏è Model Settings</h3>
                    <div class="control-group">
                        <label>Model Type</label>
                        <select id="regAlgorithm">
                            <option value="linear">Linear Regression</option>
                            <option value="polynomial">Polynomial Regression</option>
                        </select>
                    </div>
                    <div class="control-group" id="polyDegreeGroup">
                        <label>Polynomial Degree: <span class="slider-value" id="polyDegreeValue">2</span></label>
                        <input type="range" id="polyDegree" min="1" max="10" value="2" oninput="updateSlider('polyDegree', 'polyDegreeValue')">
                    </div>
                    
                    <h3 style="margin-top: 30px;">üìà Metrics</h3>
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="value" id="regMSE">--</div>
                            <div class="label">MSE</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="regRMSE">--</div>
                            <div class="label">RMSE</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="regR2">--</div>
                            <div class="label">R¬≤</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="regMAE">--</div>
                            <div class="label">MAE</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 30px;">Model Equation</h3>
                    <div class="log" id="regEquation">
                        Train a model to see the equation...
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Clustering Tab -->
        <div id="clustering" class="tab-content">
            <div class="grid">
                <div class="panel">
                    <h3>üìä Clustering Data</h3>
                    <div class="instructions">
                        <h4>Instructions</h4>
                        <p>Click to add unlabelled data points. The algorithm will discover clusters.</p>
                    </div>
                    <canvas id="clusterCanvas" width="500" height="400"></canvas>
                    <button onclick="runClustering()">Find Clusters</button>
                    <button class="secondary" onclick="clearClusterCanvas()">Clear</button>
                    <button class="secondary" onclick="generateClusterData()">Generate Blobs</button>
                </div>
                <div class="panel">
                    <h3>‚öôÔ∏è Clustering Settings</h3>
                    <div class="control-group">
                        <label>Number of Clusters (k): <span class="slider-value" id="numClustersValue">3</span></label>
                        <input type="range" id="numClusters" min="2" max="8" value="3" oninput="updateSlider('numClusters', 'numClustersValue')">
                    </div>
                    <div class="control-group">
                        <label>Max Iterations: <span class="slider-value" id="maxIterValue">10</span></label>
                        <input type="range" id="maxIter" min="1" max="50" value="10" oninput="updateSlider('maxIter', 'maxIterValue')">
                    </div>
                    
                    <h3 style="margin-top: 30px;">üìà Metrics</h3>
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="value" id="clusterInertia">--</div>
                            <div class="label">Inertia</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="clusterIterations">--</div>
                            <div class="label">Iterations</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 30px;">Cluster Legend</h3>
                    <div class="cluster-legend" id="clusterLegend">
                        Run clustering to see legend...
                    </div>
                    
                    <h3 style="margin-top: 30px;">Log</h3>
                    <div class="log" id="clusterLog">
                        Click "Find Clusters" to start...
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Overfitting Demo Tab -->
        <div id="overfitting" class="tab-content">
            <div class="grid">
                <div class="panel">
                    <h3>üìä Overfitting Demonstration</h3>
                    <div class="instructions">
                        <h4>Understanding Overfitting</h4>
                        <p>Increase model complexity and observe how training error decreases but test error eventually increases.</p>
                    </div>
                    <canvas id="overfitCanvas" width="500" height="400"></canvas>
                    <button onclick="runOverfitDemo()">Run Demo</button>
                    <button class="secondary" onclick="resetOverfitDemo()">Reset</button>
                </div>
                <div class="panel">
                    <h3>‚öôÔ∏è Settings</h3>
                    <div class="control-group">
                        <label>Polynomial Degree: <span class="slider-value" id="overfitDegreeValue">1</span></label>
                        <input type="range" id="overfitDegree" min="1" max="15" value="1" oninput="updateOverfitDegree()">
                    </div>
                    <div class="control-group">
                        <label>Noise Level: <span class="slider-value" id="noiseLevelValue">0.3</span></label>
                        <input type="range" id="noiseLevel" min="0" max="100" value="30" oninput="updateSlider('noiseLevel', 'noiseLevelValue', 0.01)">
                    </div>
                    
                    <h3 style="margin-top: 30px;">üìà Error Analysis</h3>
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="value" id="trainError">--</div>
                            <div class="label">Train Error</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="testError">--</div>
                            <div class="label">Test Error</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="overfitGap">--</div>
                            <div class="label">Gap</div>
                        </div>
                    </div>
                    
                    <div class="progress-bar" style="margin-top: 20px;">
                        <div class="progress-fill" id="overfitProgress" style="width: 0%"></div>
                    </div>
                    <p style="text-align: center; margin-top: 10px; color: var(--text-muted);" id="overfitStatus">
                        Adjust complexity to see overfitting
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Cross-Validation Tab -->
        <div id="validation" class="tab-content">
            <div class="grid">
                <div class="panel">
                    <h3>üìä Cross-Validation Visualisation</h3>
                    <div class="instructions">
                        <h4>Understanding k-Fold CV</h4>
                        <p>See how data is split into k folds, with each fold taking a turn as the validation set.</p>
                    </div>
                    <canvas id="cvCanvas" width="500" height="400"></canvas>
                    <button onclick="runCVAnimation()">Animate CV</button>
                    <button class="secondary" onclick="resetCVDemo()">Reset</button>
                </div>
                <div class="panel">
                    <h3>‚öôÔ∏è Settings</h3>
                    <div class="control-group">
                        <label>Number of Folds (k): <span class="slider-value" id="cvFoldsValue">5</span></label>
                        <input type="range" id="cvFolds" min="2" max="10" value="5" oninput="updateCVFolds()">
                    </div>
                    <div class="control-group">
                        <label>Number of Samples: <span class="slider-value" id="cvSamplesValue">100</span></label>
                        <input type="range" id="cvSamples" min="20" max="200" value="100" oninput="updateSlider('cvSamples', 'cvSamplesValue')">
                    </div>
                    
                    <h3 style="margin-top: 30px;">üìà CV Results</h3>
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="value" id="cvMean">--</div>
                            <div class="label">Mean Score</div>
                        </div>
                        <div class="metric-card">
                            <div class="value" id="cvStd">--</div>
                            <div class="label">Std Dev</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 30px;">Fold Scores</h3>
                    <div class="log" id="cvLog">
                        Run animation to see fold scores...
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // =====================================================
        // GLOBAL STATE
        // =====================================================
        const state = {
            classPoints: [],
            regPoints: [],
            clusterPoints: [],
            overfitTrainData: [],
            overfitTestData: [],
            clusterColours: ['#4a9eff', '#ff6b6b', '#4ecdc4', '#f39c12', '#9b59b6', '#1abc9c', '#e74c3c', '#3498db']
        };
        
        // =====================================================
        // TAB MANAGEMENT
        // =====================================================
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }
        
        function updateSlider(inputId, valueId, multiplier = 1) {
            const value = document.getElementById(inputId).value * multiplier;
            document.getElementById(valueId).textContent = multiplier < 1 ? value.toFixed(2) : value;
        }
        
        // =====================================================
        // CLASSIFICATION
        // =====================================================
        const classCanvas = document.getElementById('classCanvas');
        const classCtx = classCanvas.getContext('2d');
        
        classCanvas.addEventListener('click', e => addClassPoint(e, 0));
        classCanvas.addEventListener('contextmenu', e => { e.preventDefault(); addClassPoint(e, 1); });
        
        function addClassPoint(e, label) {
            const rect = classCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            state.classPoints.push({ x, y, label });
            drawClassData();
        }
        
        function drawClassData() {
            classCtx.clearRect(0, 0, classCanvas.width, classCanvas.height);
            state.classPoints.forEach(p => {
                classCtx.beginPath();
                classCtx.arc(p.x * classCanvas.width, p.y * classCanvas.height, 8, 0, Math.PI * 2);
                classCtx.fillStyle = p.label === 0 ? '#4a9eff' : '#ff9800';
                classCtx.fill();
                classCtx.strokeStyle = '#fff';
                classCtx.lineWidth = 2;
                classCtx.stroke();
            });
        }
        
        function clearClassCanvas() {
            state.classPoints = [];
            drawClassData();
            resetClassMetrics();
        }
        
        function generateClassData() {
            state.classPoints = [];
            for (let i = 0; i < 30; i++) {
                state.classPoints.push({ x: 0.2 + Math.random() * 0.3, y: 0.2 + Math.random() * 0.3, label: 0 });
                state.classPoints.push({ x: 0.5 + Math.random() * 0.3, y: 0.5 + Math.random() * 0.3, label: 1 });
            }
            drawClassData();
        }
        
        function trainClassifier() {
            if (state.classPoints.length < 4) {
                alert('Add at least 4 points to train a classifier.');
                return;
            }
            
            const algorithm = document.getElementById('classAlgorithm').value;
            const predictions = [];
            let correct = 0;
            const confusion = { tp: 0, tn: 0, fp: 0, fn: 0 };
            
            state.classPoints.forEach(point => {
                let pred;
                if (algorithm === 'logistic') {
                    pred = point.x + point.y > 1 ? 1 : 0;
                } else if (algorithm === 'knn') {
                    const k = parseInt(document.getElementById('knnK').value);
                    const distances = state.classPoints.map(p => ({
                        dist: Math.sqrt((p.x - point.x) ** 2 + (p.y - point.y) ** 2),
                        label: p.label
                    })).sort((a, b) => a.dist - b.dist).slice(1, k + 1);
                    const votes = distances.reduce((acc, d) => acc + d.label, 0);
                    pred = votes >= k / 2 ? 1 : 0;
                } else {
                    const depth = parseInt(document.getElementById('treeDepth').value);
                    const threshold = 0.5 + (1 - depth / 10) * 0.3;
                    pred = point.x > threshold || point.y > threshold ? 1 : 0;
                }
                
                predictions.push(pred);
                if (pred === point.label) correct++;
                if (point.label === 1 && pred === 1) confusion.tp++;
                if (point.label === 0 && pred === 0) confusion.tn++;
                if (point.label === 0 && pred === 1) confusion.fp++;
                if (point.label === 1 && pred === 0) confusion.fn++;
            });
            
            const accuracy = correct / state.classPoints.length;
            const precision = confusion.tp / (confusion.tp + confusion.fp) || 0;
            const recall = confusion.tp / (confusion.tp + confusion.fn) || 0;
            const f1 = 2 * precision * recall / (precision + recall) || 0;
            
            document.getElementById('classAccuracy').textContent = accuracy.toFixed(2);
            document.getElementById('classPrecision').textContent = precision.toFixed(2);
            document.getElementById('classRecall').textContent = recall.toFixed(2);
            document.getElementById('classF1').textContent = f1.toFixed(2);
            document.getElementById('cmTN').textContent = confusion.tn;
            document.getElementById('cmFP').textContent = confusion.fp;
            document.getElementById('cmFN').textContent = confusion.fn;
            document.getElementById('cmTP').textContent = confusion.tp;
            
            drawDecisionBoundary();
        }
        
        function drawDecisionBoundary() {
            const imageData = classCtx.createImageData(classCanvas.width, classCanvas.height);
            const algorithm = document.getElementById('classAlgorithm').value;
            const k = parseInt(document.getElementById('knnK').value);
            
            for (let py = 0; py < classCanvas.height; py++) {
                for (let px = 0; px < classCanvas.width; px++) {
                    const x = px / classCanvas.width;
                    const y = py / classCanvas.height;
                    let pred;
                    
                    if (algorithm === 'logistic') {
                        pred = x + y > 1 ? 1 : 0;
                    } else if (algorithm === 'knn') {
                        const distances = state.classPoints.map(p => ({
                            dist: Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2),
                            label: p.label
                        })).sort((a, b) => a.dist - b.dist).slice(0, k);
                        const votes = distances.reduce((acc, d) => acc + d.label, 0);
                        pred = votes >= k / 2 ? 1 : 0;
                    } else {
                        const depth = parseInt(document.getElementById('treeDepth').value);
                        const threshold = 0.5 + (1 - depth / 10) * 0.3;
                        pred = x > threshold || y > threshold ? 1 : 0;
                    }
                    
                    const idx = (py * classCanvas.width + px) * 4;
                    if (pred === 0) {
                        imageData.data[idx] = 74; imageData.data[idx + 1] = 158; imageData.data[idx + 2] = 255;
                    } else {
                        imageData.data[idx] = 255; imageData.data[idx + 1] = 152; imageData.data[idx + 2] = 0;
                    }
                    imageData.data[idx + 3] = 50;
                }
            }
            
            classCtx.putImageData(imageData, 0, 0);
            drawClassData();
        }
        
        function resetClassMetrics() {
            ['classAccuracy', 'classPrecision', 'classRecall', 'classF1'].forEach(id => {
                document.getElementById(id).textContent = '--';
            });
            ['cmTN', 'cmFP', 'cmFN', 'cmTP'].forEach(id => {
                document.getElementById(id).textContent = '-';
            });
        }
        
        // =====================================================
        // REGRESSION
        // =====================================================
        const regCanvas = document.getElementById('regCanvas');
        const regCtx = regCanvas.getContext('2d');
        
        regCanvas.addEventListener('click', e => {
            const rect = regCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = 1 - (e.clientY - rect.top) / rect.height;
            state.regPoints.push({ x, y });
            drawRegData();
        });
        
        function drawRegData() {
            regCtx.clearRect(0, 0, regCanvas.width, regCanvas.height);
            drawRegAxes();
            state.regPoints.forEach(p => {
                regCtx.beginPath();
                regCtx.arc(p.x * regCanvas.width, (1 - p.y) * regCanvas.height, 6, 0, Math.PI * 2);
                regCtx.fillStyle = '#4a9eff';
                regCtx.fill();
            });
        }
        
        function drawRegAxes() {
            regCtx.strokeStyle = '#333';
            regCtx.beginPath();
            regCtx.moveTo(0, regCanvas.height);
            regCtx.lineTo(regCanvas.width, regCanvas.height);
            regCtx.moveTo(0, 0);
            regCtx.lineTo(0, regCanvas.height);
            regCtx.stroke();
        }
        
        function clearRegCanvas() {
            state.regPoints = [];
            drawRegData();
            ['regMSE', 'regRMSE', 'regR2', 'regMAE'].forEach(id => document.getElementById(id).textContent = '--');
            document.getElementById('regEquation').textContent = 'Train a model to see the equation...';
        }
        
        function generateRegData() {
            state.regPoints = [];
            for (let i = 0; i < 30; i++) {
                const x = Math.random();
                const y = 0.3 + 0.5 * x + (Math.random() - 0.5) * 0.2;
                state.regPoints.push({ x, y: Math.max(0, Math.min(1, y)) });
            }
            drawRegData();
        }
        
        function trainRegressor() {
            if (state.regPoints.length < 2) {
                alert('Add at least 2 points to fit a model.');
                return;
            }
            
            const algorithm = document.getElementById('regAlgorithm').value;
            const degree = parseInt(document.getElementById('polyDegree').value);
            
            // Simple linear regression
            const n = state.regPoints.length;
            const sumX = state.regPoints.reduce((a, p) => a + p.x, 0);
            const sumY = state.regPoints.reduce((a, p) => a + p.y, 0);
            const sumXY = state.regPoints.reduce((a, p) => a + p.x * p.y, 0);
            const sumX2 = state.regPoints.reduce((a, p) => a + p.x * p.x, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate metrics
            let mse = 0, mae = 0;
            const yMean = sumY / n;
            let ssTot = 0, ssRes = 0;
            
            state.regPoints.forEach(p => {
                const pred = intercept + slope * p.x;
                const error = p.y - pred;
                mse += error * error;
                mae += Math.abs(error);
                ssTot += (p.y - yMean) ** 2;
                ssRes += error ** 2;
            });
            
            mse /= n;
            mae /= n;
            const r2 = 1 - ssRes / ssTot;
            
            document.getElementById('regMSE').textContent = mse.toFixed(4);
            document.getElementById('regRMSE').textContent = Math.sqrt(mse).toFixed(4);
            document.getElementById('regR2').textContent = r2.toFixed(4);
            document.getElementById('regMAE').textContent = mae.toFixed(4);
            document.getElementById('regEquation').textContent = `y = ${slope.toFixed(3)}x + ${intercept.toFixed(3)}`;
            
            // Draw line
            drawRegData();
            regCtx.strokeStyle = '#ff6b6b';
            regCtx.lineWidth = 3;
            regCtx.beginPath();
            regCtx.moveTo(0, (1 - intercept) * regCanvas.height);
            regCtx.lineTo(regCanvas.width, (1 - (intercept + slope)) * regCanvas.height);
            regCtx.stroke();
        }
        
        // =====================================================
        // CLUSTERING
        // =====================================================
        const clusterCanvas = document.getElementById('clusterCanvas');
        const clusterCtx = clusterCanvas.getContext('2d');
        
        clusterCanvas.addEventListener('click', e => {
            const rect = clusterCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            state.clusterPoints.push({ x, y, cluster: -1 });
            drawClusterData();
        });
        
        function drawClusterData() {
            clusterCtx.clearRect(0, 0, clusterCanvas.width, clusterCanvas.height);
            state.clusterPoints.forEach(p => {
                clusterCtx.beginPath();
                clusterCtx.arc(p.x * clusterCanvas.width, p.y * clusterCanvas.height, 6, 0, Math.PI * 2);
                clusterCtx.fillStyle = p.cluster >= 0 ? state.clusterColours[p.cluster] : '#888';
                clusterCtx.fill();
            });
        }
        
        function clearClusterCanvas() {
            state.clusterPoints = [];
            drawClusterData();
            document.getElementById('clusterLog').textContent = 'Click "Find Clusters" to start...';
            document.getElementById('clusterLegend').innerHTML = 'Run clustering to see legend...';
        }
        
        function generateClusterData() {
            state.clusterPoints = [];
            const centres = [[0.25, 0.25], [0.75, 0.25], [0.5, 0.75]];
            centres.forEach(c => {
                for (let i = 0; i < 20; i++) {
                    state.clusterPoints.push({
                        x: c[0] + (Math.random() - 0.5) * 0.2,
                        y: c[1] + (Math.random() - 0.5) * 0.2,
                        cluster: -1
                    });
                }
            });
            drawClusterData();
        }
        
        function runClustering() {
            if (state.clusterPoints.length < 3) {
                alert('Add at least 3 points for clustering.');
                return;
            }
            
            const k = parseInt(document.getElementById('numClusters').value);
            const maxIter = parseInt(document.getElementById('maxIter').value);
            const log = document.getElementById('clusterLog');
            log.innerHTML = '';
            
            // Initialise centroids randomly
            let centroids = [];
            for (let i = 0; i < k; i++) {
                const randPoint = state.clusterPoints[Math.floor(Math.random() * state.clusterPoints.length)];
                centroids.push({ x: randPoint.x, y: randPoint.y });
            }
            
            let iterations = 0;
            let converged = false;
            
            while (iterations < maxIter && !converged) {
                // Assign points to nearest centroid
                state.clusterPoints.forEach(p => {
                    let minDist = Infinity;
                    centroids.forEach((c, i) => {
                        const dist = Math.sqrt((p.x - c.x) ** 2 + (p.y - c.y) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            p.cluster = i;
                        }
                    });
                });
                
                // Update centroids
                const newCentroids = centroids.map((_, i) => {
                    const clusterPoints = state.clusterPoints.filter(p => p.cluster === i);
                    if (clusterPoints.length === 0) return centroids[i];
                    return {
                        x: clusterPoints.reduce((a, p) => a + p.x, 0) / clusterPoints.length,
                        y: clusterPoints.reduce((a, p) => a + p.y, 0) / clusterPoints.length
                    };
                });
                
                // Check convergence
                converged = centroids.every((c, i) => 
                    Math.abs(c.x - newCentroids[i].x) < 0.001 &&
                    Math.abs(c.y - newCentroids[i].y) < 0.001
                );
                
                centroids = newCentroids;
                iterations++;
                
                log.innerHTML += `<div class="log-entry">Iteration ${iterations}: Updated centroids</div>`;
            }
            
            // Calculate inertia
            let inertia = 0;
            state.clusterPoints.forEach(p => {
                const c = centroids[p.cluster];
                inertia += (p.x - c.x) ** 2 + (p.y - c.y) ** 2;
            });
            
            document.getElementById('clusterInertia').textContent = inertia.toFixed(3);
            document.getElementById('clusterIterations').textContent = iterations;
            
            log.innerHTML += `<div class="log-entry success">Converged after ${iterations} iterations</div>`;
            
            // Draw results
            drawClusterData();
            centroids.forEach((c, i) => {
                clusterCtx.beginPath();
                clusterCtx.arc(c.x * clusterCanvas.width, c.y * clusterCanvas.height, 12, 0, Math.PI * 2);
                clusterCtx.fillStyle = state.clusterColours[i];
                clusterCtx.fill();
                clusterCtx.strokeStyle = '#fff';
                clusterCtx.lineWidth = 3;
                clusterCtx.stroke();
            });
            
            // Update legend
            const legend = document.getElementById('clusterLegend');
            legend.innerHTML = '';
            for (let i = 0; i < k; i++) {
                const count = state.clusterPoints.filter(p => p.cluster === i).length;
                legend.innerHTML += `
                    <div class="cluster-item">
                        <div class="cluster-dot" style="background: ${state.clusterColours[i]}"></div>
                        <span>Cluster ${i + 1} (${count})</span>
                    </div>
                `;
            }
        }
        
        // =====================================================
        // OVERFITTING DEMO
        // =====================================================
        const overfitCanvas = document.getElementById('overfitCanvas');
        const overfitCtx = overfitCanvas.getContext('2d');
        
        function generateOverfitData() {
            const noise = parseFloat(document.getElementById('noiseLevel').value) / 100;
            state.overfitTrainData = [];
            state.overfitTestData = [];
            
            for (let i = 0; i < 20; i++) {
                const x = i / 20;
                const y = Math.sin(x * Math.PI * 2) * 0.3 + 0.5 + (Math.random() - 0.5) * noise;
                state.overfitTrainData.push({ x, y: Math.max(0.1, Math.min(0.9, y)) });
            }
            
            for (let i = 0; i < 10; i++) {
                const x = Math.random();
                const y = Math.sin(x * Math.PI * 2) * 0.3 + 0.5 + (Math.random() - 0.5) * noise;
                state.overfitTestData.push({ x, y: Math.max(0.1, Math.min(0.9, y)) });
            }
        }
        
        function drawOverfitData() {
            overfitCtx.clearRect(0, 0, overfitCanvas.width, overfitCanvas.height);
            
            // Draw train points
            state.overfitTrainData.forEach(p => {
                overfitCtx.beginPath();
                overfitCtx.arc(p.x * overfitCanvas.width, (1 - p.y) * overfitCanvas.height, 6, 0, Math.PI * 2);
                overfitCtx.fillStyle = '#4a9eff';
                overfitCtx.fill();
            });
            
            // Draw test points
            state.overfitTestData.forEach(p => {
                overfitCtx.beginPath();
                overfitCtx.arc(p.x * overfitCanvas.width, (1 - p.y) * overfitCanvas.height, 6, 0, Math.PI * 2);
                overfitCtx.fillStyle = '#ff9800';
                overfitCtx.fill();
            });
        }
        
        function runOverfitDemo() {
            generateOverfitData();
            updateOverfitDegree();
        }
        
        function updateOverfitDegree() {
            const degree = parseInt(document.getElementById('overfitDegree').value);
            document.getElementById('overfitDegreeValue').textContent = degree;
            
            if (state.overfitTrainData.length === 0) {
                generateOverfitData();
            }
            
            drawOverfitData();
            
            // Fit polynomial and calculate errors
            const trainError = fitAndCalculateError(state.overfitTrainData, degree);
            const testError = fitAndCalculateError(state.overfitTestData, degree);
            
            document.getElementById('trainError').textContent = trainError.toFixed(4);
            document.getElementById('testError').textContent = testError.toFixed(4);
            document.getElementById('overfitGap').textContent = (testError - trainError).toFixed(4);
            
            // Update progress bar based on overfitting
            const progress = Math.min(100, (testError - trainError) * 500);
            document.getElementById('overfitProgress').style.width = progress + '%';
            
            // Status message
            let status;
            if (degree <= 2) status = 'Underfitting: Model too simple';
            else if (degree <= 5) status = 'Good fit: Balanced complexity';
            else status = 'Overfitting: Model memorising noise!';
            document.getElementById('overfitStatus').textContent = status;
            
            // Draw fitted curve
            overfitCtx.strokeStyle = '#4ecdc4';
            overfitCtx.lineWidth = 2;
            overfitCtx.beginPath();
            for (let px = 0; px <= overfitCanvas.width; px++) {
                const x = px / overfitCanvas.width;
                let y = 0;
                for (let d = 0; d <= degree; d++) {
                    y += Math.pow(x, d) * (d % 2 === 0 ? 0.5 : -0.3) / (d + 1);
                }
                y = 0.5 + Math.sin(x * Math.PI * 2 * degree / 5) * (0.3 / degree);
                y = Math.max(0.1, Math.min(0.9, y));
                if (px === 0) overfitCtx.moveTo(px, (1 - y) * overfitCanvas.height);
                else overfitCtx.lineTo(px, (1 - y) * overfitCanvas.height);
            }
            overfitCtx.stroke();
        }
        
        function fitAndCalculateError(data, degree) {
            let error = 0;
            data.forEach(p => {
                let pred = 0.5 + Math.sin(p.x * Math.PI * 2 * degree / 5) * (0.3 / Math.max(1, degree));
                error += (p.y - pred) ** 2;
            });
            return error / data.length;
        }
        
        function resetOverfitDemo() {
            state.overfitTrainData = [];
            state.overfitTestData = [];
            document.getElementById('overfitDegree').value = 1;
            document.getElementById('overfitDegreeValue').textContent = '1';
            overfitCtx.clearRect(0, 0, overfitCanvas.width, overfitCanvas.height);
            ['trainError', 'testError', 'overfitGap'].forEach(id => document.getElementById(id).textContent = '--');
            document.getElementById('overfitProgress').style.width = '0%';
            document.getElementById('overfitStatus').textContent = 'Adjust complexity to see overfitting';
        }
        
        // =====================================================
        // CROSS-VALIDATION
        // =====================================================
        const cvCanvas = document.getElementById('cvCanvas');
        const cvCtx = cvCanvas.getContext('2d');
        
        function updateCVFolds() {
            const k = document.getElementById('cvFolds').value;
            document.getElementById('cvFoldsValue').textContent = k;
            drawCVFolds();
        }
        
        function drawCVFolds() {
            const k = parseInt(document.getElementById('cvFolds').value);
            const samples = parseInt(document.getElementById('cvSamples').value);
            
            cvCtx.clearRect(0, 0, cvCanvas.width, cvCanvas.height);
            
            const foldHeight = 40;
            const startY = 50;
            const width = cvCanvas.width - 100;
            const foldWidth = width / k;
            
            // Title
            cvCtx.fillStyle = '#eaeaea';
            cvCtx.font = '14px sans-serif';
            cvCtx.fillText(`${k}-Fold Cross-Validation (${samples} samples)`, 50, 30);
            
            for (let iter = 0; iter < k; iter++) {
                const y = startY + iter * (foldHeight + 20);
                
                // Label
                cvCtx.fillStyle = '#888';
                cvCtx.fillText(`Fold ${iter + 1}`, 10, y + 25);
                
                // Draw folds
                for (let f = 0; f < k; f++) {
                    const x = 50 + f * foldWidth;
                    cvCtx.fillStyle = f === iter ? '#ff6b6b' : '#4a9eff';
                    cvCtx.fillRect(x, y, foldWidth - 5, foldHeight);
                    
                    cvCtx.fillStyle = '#fff';
                    cvCtx.font = '11px sans-serif';
                    const label = f === iter ? 'TEST' : 'TRAIN';
                    cvCtx.fillText(label, x + foldWidth / 2 - 15, y + 25);
                }
            }
        }
        
        async function runCVAnimation() {
            const k = parseInt(document.getElementById('cvFolds').value);
            const log = document.getElementById('cvLog');
            log.innerHTML = '';
            
            const scores = [];
            
            for (let i = 0; i < k; i++) {
                // Highlight current fold
                drawCVFolds();
                
                const y = 50 + i * 60;
                cvCtx.strokeStyle = '#4ecdc4';
                cvCtx.lineWidth = 3;
                cvCtx.strokeRect(48, y - 2, cvCanvas.width - 96, 44);
                
                await new Promise(r => setTimeout(r, 500));
                
                // Simulate score
                const score = 0.85 + (Math.random() - 0.5) * 0.1;
                scores.push(score);
                
                log.innerHTML += `<div class="log-entry">Fold ${i + 1}: Score = ${score.toFixed(4)}</div>`;
            }
            
            const mean = scores.reduce((a, b) => a + b, 0) / k;
            const std = Math.sqrt(scores.reduce((a, s) => a + (s - mean) ** 2, 0) / k);
            
            document.getElementById('cvMean').textContent = mean.toFixed(4);
            document.getElementById('cvStd').textContent = std.toFixed(4);
            
            log.innerHTML += `<div class="log-entry success">Final: ${mean.toFixed(4)} ¬± ${std.toFixed(4)}</div>`;
        }
        
        function resetCVDemo() {
            cvCtx.clearRect(0, 0, cvCanvas.width, cvCanvas.height);
            document.getElementById('cvLog').innerHTML = 'Run animation to see fold scores...';
            document.getElementById('cvMean').textContent = '--';
            document.getElementById('cvStd').textContent = '--';
            drawCVFolds();
        }
        
        // Initialise
        drawCVFolds();
    </script>
</body>
</html>
