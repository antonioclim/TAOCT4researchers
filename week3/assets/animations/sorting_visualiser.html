<!DOCTYPE html>
<!--
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
COMPUTATIONAL THINKING FOR RESEARCHERS
Week 3: Algorithmic Complexity
Animation: Interactive Sorting Algorithm Visualiser with Timing
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This interactive visualisation demonstrates various sorting algorithms with
real-time complexity metrics, allowing researchers to understand algorithmic
behaviour empirically.

Â© 2025 Antonio Clim. All rights reserved.
See README.md for full licence terms.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualiser | Week 3: Algorithmic Complexity</title>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --accent-blue: #6bc9ff;
            --accent-green: #9be36b;
            --accent-orange: #ffa06b;
            --accent-red: #ff6b6b;
            --accent-purple: #a06bff;
            --accent-yellow: #ffd56b;
            --text-primary: #ffffff;
            --text-secondary: #aaaacc;
            --border-colour: #4a4a6a;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
            min-height: 100vh;
            color: var(--text-primary);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .controls-panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            border: 1px solid var(--border-colour);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .control-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        select, input[type="range"] {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border-colour);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .buttons-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: flex-end;
        }
        
        button {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
        }
        
        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-colour);
        }
        
        .btn-danger {
            background: var(--accent-red);
            color: white;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .visualisation-area {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-colour);
        }
        
        .bars-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 350px;
            gap: 2px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .bar {
            flex: 1;
            max-width: 40px;
            min-width: 4px;
            background: var(--accent-blue);
            border-radius: 2px 2px 0 0;
            transition: height 0.05s ease, background-color 0.1s ease;
            position: relative;
        }
        
        .bar.comparing {
            background: var(--accent-orange) !important;
        }
        
        .bar.swapping {
            background: var(--accent-red) !important;
        }
        
        .bar.sorted {
            background: var(--accent-green) !important;
        }
        
        .bar.pivot {
            background: var(--accent-purple) !important;
        }
        
        .bar.minimum {
            background: var(--accent-yellow) !important;
        }
        
        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid var(--border-colour);
        }
        
        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .metric-comparisons .metric-value { color: var(--accent-orange); }
        .metric-swaps .metric-value { color: var(--accent-red); }
        .metric-time .metric-value { color: var(--accent-green); }
        .metric-complexity .metric-value { color: var(--accent-purple); font-size: 1.2rem; }
        
        .info-panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-colour);
        }
        
        .algorithm-info h3 {
            color: var(--accent-blue);
            margin-bottom: 10px;
        }
        
        .algorithm-info p {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .complexity-table th,
        .complexity-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border-colour);
        }
        
        .complexity-table th {
            color: var(--accent-yellow);
            font-size: 0.85rem;
        }
        
        .complexity-table td {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-colour);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }
        
        .legend-colour {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        
        .speed-display {
            font-family: 'Courier New', monospace;
            color: var(--accent-blue);
            min-width: 60px;
            text-align: right;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-colour);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            .bars-container { height: 250px; }
            .metric-value { font-size: 1.4rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ”¬ Sorting Algorithm Visualiser</h1>
            <p class="subtitle">Week 3: Algorithmic Complexity | Interactive Complexity Analysis</p>
        </header>
        
        <div class="controls-panel">
            <div class="control-group">
                <label for="algorithm">Algorithm</label>
                <select id="algorithm">
                    <option value="bubble">Bubble Sort â€” O(nÂ²)</option>
                    <option value="selection">Selection Sort â€” O(nÂ²)</option>
                    <option value="insertion">Insertion Sort â€” O(nÂ²)</option>
                    <option value="merge">Merge Sort â€” O(n log n)</option>
                    <option value="quick">Quick Sort â€” O(n log n) avg</option>
                    <option value="heap">Heap Sort â€” O(n log n)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="arraySize">Array Size: <span id="sizeDisplay">50</span></label>
                <input type="range" id="arraySize" min="10" max="200" value="50">
            </div>
            
            <div class="control-group">
                <label for="speed">Speed: <span id="speedDisplay" class="speed-display">50 ms</span></label>
                <input type="range" id="speed" min="1" max="200" value="50">
            </div>
            
            <div class="control-group">
                <label for="dataType">Initial Data</label>
                <select id="dataType">
                    <option value="random">Random</option>
                    <option value="nearly-sorted">Nearly Sorted</option>
                    <option value="reversed">Reversed</option>
                    <option value="few-unique">Few Unique Values</option>
                </select>
            </div>
            
            <div class="control-group buttons-row">
                <button id="startBtn" class="btn-primary">â–¶ Start</button>
                <button id="pauseBtn" class="btn-secondary" disabled>â¸ Pause</button>
                <button id="resetBtn" class="btn-danger">â†» Reset</button>
            </div>
        </div>
        
        <div class="metrics-panel">
            <div class="metric-card metric-comparisons">
                <div class="metric-value" id="comparisons">0</div>
                <div class="metric-label">Comparisons</div>
            </div>
            <div class="metric-card metric-swaps">
                <div class="metric-value" id="swaps">0</div>
                <div class="metric-label">Swaps/Writes</div>
            </div>
            <div class="metric-card metric-time">
                <div class="metric-value" id="elapsedTime">0.00s</div>
                <div class="metric-label">Elapsed Time</div>
            </div>
            <div class="metric-card metric-complexity">
                <div class="metric-value" id="expectedOps">â€”</div>
                <div class="metric-label">Expected Ops (n=<span id="currentN">50</span>)</div>
            </div>
        </div>
        
        <div class="visualisation-area">
            <div class="bars-container" id="barsContainer"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-colour" style="background: var(--accent-blue)"></div>
                    <span>Unsorted</span>
                </div>
                <div class="legend-item">
                    <div class="legend-colour" style="background: var(--accent-orange)"></div>
                    <span>Comparing</span>
                </div>
                <div class="legend-item">
                    <div class="legend-colour" style="background: var(--accent-red)"></div>
                    <span>Swapping</span>
                </div>
                <div class="legend-item">
                    <div class="legend-colour" style="background: var(--accent-purple)"></div>
                    <span>Pivot</span>
                </div>
                <div class="legend-item">
                    <div class="legend-colour" style="background: var(--accent-yellow)"></div>
                    <span>Minimum</span>
                </div>
                <div class="legend-item">
                    <div class="legend-colour" style="background: var(--accent-green)"></div>
                    <span>Sorted</span>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="algorithm-info" id="algorithmInfo">
                <h3>Bubble Sort</h3>
                <p>Bubble sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.</p>
                <p><strong>Best for:</strong> Educational purposes, small datasets, nearly sorted data.</p>
            </div>
            
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best Case</th>
                        <th>Average</th>
                        <th>Worst Case</th>
                        <th>Space</th>
                        <th>Stable</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Bubble Sort</td>
                        <td>O(n)</td>
                        <td>O(nÂ²)</td>
                        <td>O(nÂ²)</td>
                        <td>O(1)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Selection Sort</td>
                        <td>O(nÂ²)</td>
                        <td>O(nÂ²)</td>
                        <td>O(nÂ²)</td>
                        <td>O(1)</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Insertion Sort</td>
                        <td>O(n)</td>
                        <td>O(nÂ²)</td>
                        <td>O(nÂ²)</td>
                        <td>O(1)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Merge Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td>Quick Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(nÂ²)</td>
                        <td>O(log n)</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Heap Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(1)</td>
                        <td>No</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <footer>
            <p>Â© 2025 Antonio Clim. All rights reserved. | The Art of Computational Thinking for Researchers</p>
        </footer>
    </div>
    
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE MANAGEMENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const state = {
            array: [],
            originalArray: [],
            isRunning: false,
            isPaused: false,
            comparisons: 0,
            swaps: 0,
            startTime: null,
            timerInterval: null,
            animationSpeed: 50,
            sortGenerator: null
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DOM ELEMENTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const elements = {
            algorithm: document.getElementById('algorithm'),
            arraySize: document.getElementById('arraySize'),
            speed: document.getElementById('speed'),
            dataType: document.getElementById('dataType'),
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            barsContainer: document.getElementById('barsContainer'),
            comparisons: document.getElementById('comparisons'),
            swaps: document.getElementById('swaps'),
            elapsedTime: document.getElementById('elapsedTime'),
            expectedOps: document.getElementById('expectedOps'),
            currentN: document.getElementById('currentN'),
            sizeDisplay: document.getElementById('sizeDisplay'),
            speedDisplay: document.getElementById('speedDisplay'),
            algorithmInfo: document.getElementById('algorithmInfo')
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALGORITHM DESCRIPTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const algorithmDescriptions = {
            bubble: {
                name: 'Bubble Sort',
                description: 'Bubble sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.',
                bestFor: 'Educational purposes, small datasets, nearly sorted data.'
            },
            selection: {
                name: 'Selection Sort',
                description: 'Selection sort divides the input into a sorted and unsorted region. It repeatedly selects the smallest element from the unsorted region and moves it to the end of the sorted region.',
                bestFor: 'Small datasets, situations where memory writes are expensive.'
            },
            insertion: {
                name: 'Insertion Sort',
                description: 'Insertion sort builds the final sorted array one item at a time. It iterates through the input, removing one element and finding its correct position in the sorted portion.',
                bestFor: 'Small datasets, nearly sorted data, online sorting (streaming data).'
            },
            merge: {
                name: 'Merge Sort',
                description: 'Merge sort is a divide-and-conquer algorithm that recursively divides the array in half, sorts each half, then merges them back together in sorted order.',
                bestFor: 'Large datasets, linked lists, external sorting, guaranteed O(n log n).'
            },
            quick: {
                name: 'Quick Sort',
                description: 'Quick sort selects a pivot element and partitions the array around it, placing smaller elements before and larger elements after. It then recursively sorts the partitions.',
                bestFor: 'General-purpose sorting, in-place sorting, cache efficiency.'
            },
            heap: {
                name: 'Heap Sort',
                description: 'Heap sort builds a max-heap from the input, then repeatedly extracts the maximum element and rebuilds the heap until all elements are sorted.',
                bestFor: 'Guaranteed O(n log n), in-place sorting, priority queue applications.'
            }
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ARRAY GENERATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function generateArray(size, type) {
            let arr = [];
            
            switch (type) {
                case 'random':
                    for (let i = 0; i < size; i++) {
                        arr.push(Math.floor(Math.random() * 100) + 1);
                    }
                    break;
                    
                case 'nearly-sorted':
                    for (let i = 0; i < size; i++) {
                        arr.push(i + 1);
                    }
                    // Swap a few random pairs
                    const swapCount = Math.floor(size * 0.1);
                    for (let i = 0; i < swapCount; i++) {
                        const idx1 = Math.floor(Math.random() * size);
                        const idx2 = Math.floor(Math.random() * size);
                        [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
                    }
                    break;
                    
                case 'reversed':
                    for (let i = size; i > 0; i--) {
                        arr.push(i);
                    }
                    break;
                    
                case 'few-unique':
                    const uniqueValues = [10, 30, 50, 70, 90];
                    for (let i = 0; i < size; i++) {
                        arr.push(uniqueValues[Math.floor(Math.random() * uniqueValues.length)]);
                    }
                    break;
            }
            
            return arr;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VISUALISATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function renderBars(highlights = {}) {
            const maxVal = Math.max(...state.array);
            elements.barsContainer.innerHTML = '';
            
            state.array.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(value / maxVal) * 100}%`;
                
                if (highlights.comparing && highlights.comparing.includes(index)) {
                    bar.classList.add('comparing');
                }
                if (highlights.swapping && highlights.swapping.includes(index)) {
                    bar.classList.add('swapping');
                }
                if (highlights.sorted && highlights.sorted.includes(index)) {
                    bar.classList.add('sorted');
                }
                if (highlights.pivot === index) {
                    bar.classList.add('pivot');
                }
                if (highlights.minimum === index) {
                    bar.classList.add('minimum');
                }
                
                elements.barsContainer.appendChild(bar);
            });
        }
        
        function updateMetrics() {
            elements.comparisons.textContent = state.comparisons.toLocaleString();
            elements.swaps.textContent = state.swaps.toLocaleString();
        }
        
        function updateExpectedOps() {
            const n = state.array.length;
            const algo = elements.algorithm.value;
            let expected = '';
            
            switch (algo) {
                case 'bubble':
                case 'selection':
                case 'insertion':
                    expected = `~${Math.floor(n * n / 2).toLocaleString()}`;
                    break;
                case 'merge':
                case 'quick':
                case 'heap':
                    expected = `~${Math.floor(n * Math.log2(n)).toLocaleString()}`;
                    break;
            }
            
            elements.expectedOps.textContent = expected;
            elements.currentN.textContent = n;
        }
        
        function updateAlgorithmInfo() {
            const info = algorithmDescriptions[elements.algorithm.value];
            elements.algorithmInfo.innerHTML = `
                <h3>${info.name}</h3>
                <p>${info.description}</p>
                <p><strong>Best for:</strong> ${info.bestFor}</p>
            `;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TIMER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startTimer() {
            state.startTime = performance.now();
            state.timerInterval = setInterval(() => {
                if (!state.isPaused) {
                    const elapsed = (performance.now() - state.startTime) / 1000;
                    elements.elapsedTime.textContent = elapsed.toFixed(2) + 's';
                }
            }, 50);
        }
        
        function stopTimer() {
            if (state.timerInterval) {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SORTING ALGORITHMS (Generator Functions)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function* bubbleSort(arr) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let swapped = false;
                for (let j = 0; j < n - i - 1; j++) {
                    state.comparisons++;
                    yield { comparing: [j, j + 1] };
                    
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        state.swaps++;
                        swapped = true;
                        yield { swapping: [j, j + 1] };
                    }
                }
                yield { sorted: Array.from({ length: i + 1 }, (_, k) => n - 1 - k) };
                if (!swapped) break;
            }
            yield { sorted: Array.from({ length: n }, (_, k) => k) };
        }
        
        function* selectionSort(arr) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                yield { minimum: minIdx, sorted: Array.from({ length: i }, (_, k) => k) };
                
                for (let j = i + 1; j < n; j++) {
                    state.comparisons++;
                    yield { comparing: [minIdx, j], minimum: minIdx, sorted: Array.from({ length: i }, (_, k) => k) };
                    
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                        yield { minimum: minIdx, sorted: Array.from({ length: i }, (_, k) => k) };
                    }
                }
                
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    state.swaps++;
                    yield { swapping: [i, minIdx], sorted: Array.from({ length: i }, (_, k) => k) };
                }
            }
            yield { sorted: Array.from({ length: n }, (_, k) => k) };
        }
        
        function* insertionSort(arr) {
            const n = arr.length;
            for (let i = 1; i < n; i++) {
                const key = arr[i];
                let j = i - 1;
                
                yield { comparing: [i], sorted: Array.from({ length: i }, (_, k) => k) };
                
                while (j >= 0 && arr[j] > key) {
                    state.comparisons++;
                    arr[j + 1] = arr[j];
                    state.swaps++;
                    yield { swapping: [j, j + 1] };
                    j--;
                }
                state.comparisons++;
                arr[j + 1] = key;
            }
            yield { sorted: Array.from({ length: n }, (_, k) => k) };
        }
        
        function* mergeSort(arr, start = 0, end = arr.length - 1) {
            if (start >= end) {
                yield { sorted: [start] };
                return;
            }
            
            const mid = Math.floor((start + end) / 2);
            yield* mergeSort(arr, start, mid);
            yield* mergeSort(arr, mid + 1, end);
            yield* merge(arr, start, mid, end);
        }
        
        function* merge(arr, start, mid, end) {
            const left = arr.slice(start, mid + 1);
            const right = arr.slice(mid + 1, end + 1);
            let i = 0, j = 0, k = start;
            
            while (i < left.length && j < right.length) {
                state.comparisons++;
                yield { comparing: [start + i, mid + 1 + j] };
                
                if (left[i] <= right[j]) {
                    arr[k] = left[i];
                    i++;
                } else {
                    arr[k] = right[j];
                    j++;
                }
                state.swaps++;
                yield { swapping: [k] };
                k++;
            }
            
            while (i < left.length) {
                arr[k] = left[i];
                state.swaps++;
                yield { swapping: [k] };
                i++;
                k++;
            }
            
            while (j < right.length) {
                arr[k] = right[j];
                state.swaps++;
                yield { swapping: [k] };
                j++;
                k++;
            }
            
            yield { sorted: Array.from({ length: end - start + 1 }, (_, idx) => start + idx) };
        }
        
        function* quickSort(arr, low = 0, high = arr.length - 1) {
            if (low < high) {
                const pivotResult = yield* partition(arr, low, high);
                yield* quickSort(arr, low, pivotResult - 1);
                yield* quickSort(arr, pivotResult + 1, high);
            }
            if (low === 0 && high === arr.length - 1) {
                yield { sorted: Array.from({ length: arr.length }, (_, k) => k) };
            }
        }
        
        function* partition(arr, low, high) {
            const pivot = arr[high];
            yield { pivot: high };
            let i = low - 1;
            
            for (let j = low; j < high; j++) {
                state.comparisons++;
                yield { comparing: [j, high], pivot: high };
                
                if (arr[j] < pivot) {
                    i++;
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    state.swaps++;
                    yield { swapping: [i, j], pivot: high };
                }
            }
            
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            state.swaps++;
            yield { swapping: [i + 1, high] };
            
            return i + 1;
        }
        
        function* heapSort(arr) {
            const n = arr.length;
            
            // Build max heap
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                yield* heapify(arr, n, i);
            }
            
            // Extract elements from heap
            for (let i = n - 1; i > 0; i--) {
                [arr[0], arr[i]] = [arr[i], arr[0]];
                state.swaps++;
                yield { swapping: [0, i], sorted: Array.from({ length: n - i }, (_, k) => n - 1 - k) };
                yield* heapify(arr, i, 0);
            }
            
            yield { sorted: Array.from({ length: n }, (_, k) => k) };
        }
        
        function* heapify(arr, n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            
            if (left < n) {
                state.comparisons++;
                yield { comparing: [largest, left] };
                if (arr[left] > arr[largest]) {
                    largest = left;
                }
            }
            
            if (right < n) {
                state.comparisons++;
                yield { comparing: [largest, right] };
                if (arr[right] > arr[largest]) {
                    largest = right;
                }
            }
            
            if (largest !== i) {
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                state.swaps++;
                yield { swapping: [i, largest] };
                yield* heapify(arr, n, largest);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ANIMATION CONTROLLER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function runAnimation() {
            const algorithmGenerators = {
                bubble: bubbleSort,
                selection: selectionSort,
                insertion: insertionSort,
                merge: mergeSort,
                quick: quickSort,
                heap: heapSort
            };
            
            state.sortGenerator = algorithmGenerators[elements.algorithm.value](state.array);
            
            for (const step of state.sortGenerator) {
                if (!state.isRunning) break;
                
                while (state.isPaused) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (!state.isRunning) return;
                }
                
                renderBars(step);
                updateMetrics();
                await new Promise(resolve => setTimeout(resolve, state.animationSpeed));
            }
            
            if (state.isRunning) {
                // Final render with all bars sorted
                renderBars({ sorted: Array.from({ length: state.array.length }, (_, k) => k) });
                finishSorting();
            }
        }
        
        function finishSorting() {
            state.isRunning = false;
            stopTimer();
            elements.startBtn.disabled = false;
            elements.pauseBtn.disabled = true;
            elements.startBtn.textContent = 'â–¶ Start';
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        elements.startBtn.addEventListener('click', () => {
            if (!state.isRunning) {
                state.isRunning = true;
                state.isPaused = false;
                state.comparisons = 0;
                state.swaps = 0;
                updateMetrics();
                elements.startBtn.disabled = true;
                elements.pauseBtn.disabled = false;
                elements.pauseBtn.textContent = 'â¸ Pause';
                startTimer();
                runAnimation();
            }
        });
        
        elements.pauseBtn.addEventListener('click', () => {
            if (state.isRunning) {
                state.isPaused = !state.isPaused;
                elements.pauseBtn.textContent = state.isPaused ? 'â–¶ Resume' : 'â¸ Pause';
            }
        });
        
        elements.resetBtn.addEventListener('click', () => {
            state.isRunning = false;
            state.isPaused = false;
            stopTimer();
            state.array = [...state.originalArray];
            state.comparisons = 0;
            state.swaps = 0;
            updateMetrics();
            elements.elapsedTime.textContent = '0.00s';
            elements.startBtn.disabled = false;
            elements.pauseBtn.disabled = true;
            elements.startBtn.textContent = 'â–¶ Start';
            elements.pauseBtn.textContent = 'â¸ Pause';
            renderBars();
        });
        
        elements.arraySize.addEventListener('input', () => {
            const size = parseInt(elements.arraySize.value);
            elements.sizeDisplay.textContent = size;
            state.array = generateArray(size, elements.dataType.value);
            state.originalArray = [...state.array];
            state.comparisons = 0;
            state.swaps = 0;
            updateMetrics();
            updateExpectedOps();
            renderBars();
        });
        
        elements.speed.addEventListener('input', () => {
            state.animationSpeed = 201 - parseInt(elements.speed.value);
            elements.speedDisplay.textContent = state.animationSpeed + ' ms';
        });
        
        elements.dataType.addEventListener('change', () => {
            const size = parseInt(elements.arraySize.value);
            state.array = generateArray(size, elements.dataType.value);
            state.originalArray = [...state.array];
            state.comparisons = 0;
            state.swaps = 0;
            updateMetrics();
            renderBars();
        });
        
        elements.algorithm.addEventListener('change', () => {
            updateAlgorithmInfo();
            updateExpectedOps();
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALISATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function init() {
            const size = parseInt(elements.arraySize.value);
            state.array = generateArray(size, elements.dataType.value);
            state.originalArray = [...state.array];
            state.animationSpeed = 201 - parseInt(elements.speed.value);
            elements.speedDisplay.textContent = state.animationSpeed + ' ms';
            updateAlgorithmInfo();
            updateExpectedOps();
            renderBars();
        }
        
        init();
    </script>
</body>
</html>
